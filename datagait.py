# -*- coding: utf-8 -*-
"""DataGait.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1A93Woh0b6V43c5hS2QIhDXlOGriKhirD
"""

'''
from google.colab import files
uploaded = files.upload()
'''

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.animation
import plotly.graph_objects as go
from scipy.spatial.distance import cdist
import math

import joblib
data = joblib.load("skeletons_labels.json")
num_frames = len(data['vid_name'])
diag = data['Diag']
vidname = data['vid_name']

video_name = []
video_name_init = []
video_name_diag = []

name = vidname[0]
video_name.append(name)
video_name_init.append(0)
video_name_diag.append(diag[0])
counter = 0
print("#%d vdeoo_name=%s video_name_init=%d"%(counter,video_name[counter],video_name_init[counter]))

for i in range(num_frames-1):
    if vidname[i+1]!=vidname[i]:
        counter += 1
        video_name.append(vidname[i+1])
        video_name_init.append(i+1)
        video_name_diag.append(diag[i+1])
        print("#%d vdeoo_name=%s video_name_init=%d duration of previous video:%d diagnose:%d"%(\
            counter,\
            video_name[counter],video_name_init[counter],video_name_init[counter]-video_name_init[counter-1],\
            video_name_diag[counter]))

video_initial = []
video_duration = []
video_num = counter+1
video_initial.append(0)
for k in range(video_num-1):
    if k>0:
        video_initial.append(video_name_init[k])
    video_duration.append(video_name_init[k+1]-video_name_init[k])
video_duration.append(num_frames-video_name_init[video_num-1])

video_list_joints = []
k=3 ## number of video
video_diagnosis = video_name_diag[k]
initial = video_initial[k]
duration = video_duration[k]
video_list_joints.append(data['joints3D'][initial:initial+duration,:,:])
print(video_list_joints[0][:,0,0])
print(np.shape(video_list_joints))
data_final = video_list_joints[0]
#quit()

shape__ = np.shape(video_list_joints)
num_time = shape__[1]


#t = np.array([0.1*np.ones(10)*i for i in range(100)]).flatten()
t = np.linspace(0,num_time,num_time)
b = np.zeros((num_time,3))

num_joints_shown = 25
x = np.zeros((num_joints_shown,num_time,3))
joint = np.arange(0,0+num_joints_shown,1)
#joint_num = range(num_joints_shown)#for k in range(num_joints_shown):
fig = plt.figure(figsize=(8,8))
for k in range(num_joints_shown):
    x[k,:,0]=data_final[:,joint[k],0]
    x[k,:,1]=data_final[:,joint[k],2]
    x[k,:,2]=data_final[:,joint[k],1]
    if k%10 == 1:
        kk = k+1
        ax = plt.subplot(1,3,1)
        plt.plot(range(num_time),x[k,:,0])
        ax = plt.subplot(1,3,2)
        plt.plot(range(num_time),x[k,:,1])
        ax = plt.subplot(1,3,3)
        plt.plot(range(num_time),x[k,:,2])

#joint1 = 1
#x[0,:,0]=data_final[:,joint1,0]
#x[0,:,1]=data_final[:,joint1,1]
#x[0,:,2]=data_final[:,joint1,2]
#joint2 = 2
#x[1,:,0]=data_final[:,joint2,0]
#x[1,:,1]=data_final[:,joint2,1]
#x[1,:,2]=data_final[:,joint2,2]

xmax = -1000000
xmin = 10000000
ymax = -1000000
ymin = 10000000
zmax = -1000000
zmin = 10000000
for k in range(num_joints_shown):
    if xmax<np.max(x[k,:,0]):
        xmax = np.max(x[k,:,0])
    if xmin>np.min(x[k,:,0]):
        xmin = np.min(x[k,:,0])
    if ymax<np.max(x[k,:,1]):
        ymax = np.max(x[k,:,1])
    if ymin>np.min(x[k,:,1]):
        ymin = np.min(x[k,:,1])
    if zmax<np.max(x[k,:,2]):
        zmax = np.max(x[k,:,2])
    if zmin>np.min(x[k,:,2]):
        zmin = np.min(x[k,:,2])
#
#xmax=max(np.max(x[0,:,0]),np.max(x[1,:,0]))
#ymax=max(np.max(x[0,:,1]),np.max(x[1,:,1]))
#zmax=max(np.max(x[0,:,2]),np.max(x[1,:,2]))
#xmin=min(np.min(x[0,:,0]),np.min(x[1,:,0]))
#ymin=min(np.min(x[0,:,1]),np.min(x[1,:,1]))
#zmin=min(np.min(x[0,:,2]),np.min(x[1,:,2]))


df_list = []
sc_list = []
fig = plt.figure()
ax = fig.add_subplot(111,projection='3d')
label = 'subject with diagnosis #%d'%video_diagnosis
title = ax.set_title(label)
for k in range(num_joints_shown):
    df_list.append(pd.DataFrame(x[k,:,:], columns=["x","y","z"]))
    sc_list.append(ax.scatter([],[],[],alpha=0.5))

def update(i):
    range_=1
    label1 = label+'  time step:%d'%i
    title.set_text(label1)
    for k in range(num_joints_shown):
        df = df_list[k]
        sc = sc_list[k]
        if i>range_:
            sc._offsets3d = (df.x.values[i-range_:i], df.y.values[i-range_:i], df.z.values[i-range_:i])
        else:
            sc._offsets3d = (df.x.values[i-range_:i], df.y.values[i-range_:i], df.z.values[i-range_:i])

ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')
ax.set_xlim(xmin,xmax)
ax.set_ylim(ymin,ymax)
ax.set_zlim(zmin,zmax)

ani = matplotlib.animation.FuncAnimation(fig, update, frames=len(df_list[0]), interval=50)

plt.tight_layout()
plt.show()

'''
y = x[10,:,:]

T=y.shape[0]
times = np.linspace(0,T,T)

plt.figure()
plt.plot(times, y[:,0], color='red')
plt.plot(times, y[:,1], color='blue')
plt.plot(times, y[:,2], color='green')
plt.title("Right Wrist movement of each coordinate")

#plot trajectory
figure = plt.figure()
ax = figure.add_subplot(111, projection='3d')
ax.scatter(y[:, 0],y[:,1],y[:,2], marker='o')

figu = go.Figure(data=[go.Scatter3d(x=y[:, 0] , y=y[:,1], z=y[:,2], mode='markers', marker=dict(size=5))])
figu.update_layout(scene=dict(xaxis_title='X1', yaxis_title='X2', zaxis_title='X3'))
figu.update_layout(scene=dict(aspectmode="cube"))

# trajectoire anim√©e
X1 = y[:, 0]
X2 = y[:, 1]
X3 = y[:, 2]
for i in range(0,X1.shape[0]-4,1):
  print(i,"/",X1.shape[0]-5)
  fig = plt.figure()
  ax = fig.add_subplot(111, projection='3d')
  ax.scatter(X1[i],X2[i],X3[i], color='red', marker='o')
  ax.scatter(X1[i+1],X2[i+1],X3[i+1], color='red', marker='o')
  ax.scatter(X1[i+2],X2[i+2],X3[i+2], color='red', marker='o')
  ax.scatter(X1[i+3],X2[i+3],X3[i+3], color='red', marker='o')
  ax.scatter(X1[i+4],X2[i+4],X3[i+4], color='red', marker='o')
  ax.plot(X1,X2,X3)
  plt.show()

  D = cdist(y, y, 'euclidean')

step = 0.001
epsi = 0
#nbr_epsi = int(math.ceil(np.max(D))/(10*step))
nbr_epsi = int(math.ceil(np.max(D))/step)

Entropy = np.zeros(nbr_epsi)
Epsi = np.zeros(nbr_epsi)
trP = np.zeros(nbr_epsi)
hr = np.zeros(nbr_epsi)
hc = np.zeros(nbr_epsi)
u = np.zeros(nbr_epsi)

for e in range(nbr_epsi):
  epsi = epsi + step
  R = np.array(D<epsi)

  R=np.tril(R)
  R=R.astype(int)
  #print(R)
  #print('')


  #------------------------------------------------------------------------------
  #Rewriting grammar
  Serie=np.zeros((R.shape[1]))

  for i in range(R.shape[1]):
    Serie[i]=i+1

  for i in range(R.shape[0]):
    Indx = np.where(R[R.shape[0]-1-i, :]!=0)
    Valmin = int(Serie[np.min(Indx[0])])
    for j in Indx[0]:
        if Valmin < Serie[j]:
          Serie[Serie==Serie[j]] = Valmin
  #-----------------------------------------------------------------------------
  #Writing zeros
  newSerie = np.array(Serie)
  for i in range(Serie.shape[0]):
    if i != 0 and i != Serie.shape[0]-1:
      if Serie[i-1]!=Serie[i] and Serie[i]!=Serie[i+1]:
        newSerie[i]=0
    if i==0:
      if Serie[i]!=Serie[i+1] and Serie[i]!=Serie[Serie.shape[0]-1]:
        newSerie[i]=0
    if i==Serie.shape[0]-1:
      if Serie[i]!=Serie[i-1] and Serie[i]!=Serie[0]:
        newSerie[i]=0

  #-----------------------------------------------------------------------------
  #Writing continuous number's sequence
  sort = 0
  Ser = np.sort(newSerie)
  S = np.unique(Ser)
  for i in S:
    newSerie = np.where(newSerie == i, sort, newSerie)
    sort = sort+1

  #----------------------------------------------------------------------------
  #Entropy
  Serie=newSerie
  Serie=Serie.astype(int)
  p = np.array(np.unique(Serie).shape[0])
  H=0

  occurrences = np.bincount(Serie)
  for valeur, nb_occurrences in enumerate(occurrences):
    if nb_occurrences > 0:
      pi = nb_occurrences/Serie.shape[0]
      H=H+pi*np.log2(pi)

  Hneg = -H
  Entropy[e]= Hneg
  Epsi[e] = epsi

# ------------------------------------------------------------------------------
# Utility
  n = np.max(Serie)+1
  if n>2:
    r=0
    q=0

    for i in range(len(Serie)-1):
      if Serie[i] == 0 and Serie[i+1]!=0:
        r = r+1
      elif Serie[i] != 0 and Serie[i+1] == 0:
        q = q+1

    r=r/(len(Serie)-1)
    q=q/(len(Serie)-1)
    trP[e] = 1+(n-1)*(1-q-r)

    numc = 0
    numr = 0
    pi0 = np.zeros(n)
    p0i = np.zeros(n)

    for i in Serie:
      if i == 0 and numc != 0:
        pi0[incc-1] += 1
      elif i != 0:
        incc = i
      if i != 0 and numr == 0:
        incr = i
        p0i[incr-1] += 1
      numr = i
      numc = i
    shc = 0
    shr = 0
    for i in range(len(pi0)):
      if pi0[i] != 0:
        pi0_prime = pi0[i]/np.sum(pi0)
        shc = shc + pi0_prime*math.log(pi0_prime)
      if p0i[i] != 0:
        p0i_prime = p0i[i]/np.sum(p0i)
        shr = shr + p0i_prime*math.log(p0i_prime)

    hc[e] = -shc*1/math.log(n-1)
    hr[e] = -shr*1/math.log(n-1)
  else:
    hc[e] = 0
    hr[e] = 0

  u[e] = 1/(n+2) * (trP[e] + hr[e] + hc[e])

#------------------------------------------------------------------------------
# Results epsilon
Hmax = np.max(Entropy)
IndxHmax = np.argmax(Entropy)
EpsiOptiH = Epsi[IndxHmax]
print('---------Entropy----------')
print('Entropy=',round(Hmax, 3), '     Epsilon=',round(EpsiOptiH, 3))

fig=plt.figure()
plt.plot(Epsi, Entropy)


Umax = np.max(u)
IndxUmax = np.argmax(u)
EpsiOptiU = Epsi[IndxUmax]

print('----------Utility-------------')
print('Utility=',round(Umax, 3), '     Epsilon=',round(EpsiOptiU, 3))
f=plt.figure()
plt.plot(Epsi, u)

#epsi = EpsiOptiH
#epsi = EpsiOptiU
epsi = (EpsiOptiH+EpsiOptiU)/2
#epsi = 10
#epsi=0.0173

R = np.array(D<epsi)
print(R)
print('')

#------------------------------------------------------------------------------
#plot recurrence plot
x1, y1 = np.where(R == 1)
fig=plt.figure()
plt.scatter(x1, y1, c='black', marker='o')

#------------------------------------------------------------------------------
#Rewritting grammar
R=np.tril(R)
R=R.astype(int)

Serie=np.zeros((R.shape[1]))

for i in range(R.shape[1]):
  Serie[i]=i+1

for i in range(R.shape[0]):
  Indx = np.where(R[R.shape[0]-1-i, :]!=0)
  Valmin = int(Serie[np.min(Indx[0])])
  for j in Indx[0]:
      if Valmin < Serie[j]:
        Serie[Serie==Serie[j]] = Valmin

#--------------------------------------------------------------------------------
#Writing zeros

newSerie = np.array(Serie)
for i in range(Serie.shape[0]):
  if i != 0 and i != Serie.shape[0]-1:
    if Serie[i-1]!=Serie[i] and Serie[i]!=Serie[i+1]:
      newSerie[i]=0

  if i==0:
    if Serie[i]!=Serie[i+1] and Serie[i]!=Serie[Serie.shape[0]-1]:
      newSerie[i]=0
  if i==Serie.shape[0]-1:
    if Serie[i]!=Serie[i-1] and Serie[i]!=Serie[0]:
      newSerie[i]=0

#------------------------------------------------------------------------------
#Sorting

sort = 0
Ser = np.sort(newSerie)
S = np.unique(Ser)
for i in S:
  newSerie = np.where(newSerie == i, sort, newSerie)
  sort = sort+1
#
print('Final symbolic series = ', newSerie)

#-------------------------------------------------------------------------------
#plot colored serie

position = 0
palette = ['red', 'blue', 'yellow', 'green', 'purple', 'orange', 'black', 'pink', 'brown', 'gray', 'turquoise', 'indigo', 'beige', 'olive', 'cyan', 'magenta', 'gold', 'silver', 'coral', 'lavender', 'chartreuse', 'orangered', 'aquamarine', 'skyblue', 'pumpkin', 'emerald']

fig, ax = plt.subplots()
for couleur in newSerie:
    ax.barh(0, 1, color=palette[int(couleur)], height=0.2, left=position)
    position += 1

ax.set_ylim(-0.5, 0.5)
ax.axis('off')
plt.show()

#-------------------------------------------------------------------------------
#plot colored trajectory
figure = plt.figure()
ax = figure.add_subplot(111, projection='3d')
for i in range(newSerie.shape[0]):
  ax.scatter(y[i, 0],y[i,1],y[i,2], color=palette[int(newSerie[i])], marker='o')
'''