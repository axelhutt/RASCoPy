# -*- coding: utf-8 -*-
"""Symbolic_series.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nqBuBfswdkOvgyHHWYO6FnsTOp-mgbdu
"""

import numpy as np
import matplotlib.pyplot as plt
from RASCoPy import recurrence, opti_epsi
import os
import sys
from scipy.stats import mannwhitneyu


def symbolic_serie(R, visu=None, back_file=None):

  #------------------------------------------------------------------------------
  #Rewriting grammar
  Serie=np.zeros((R.shape[1]))

  for i in range(R.shape[1]):
    Serie[i]=i+1

  for i in range(R.shape[0]):
    Indx = np.where(R[R.shape[0]-1-i, :]!=0)
    Valmin = 1000000000

    for k in Indx[0]:
      if Serie[k] <= Valmin:
        Valmin = Serie[k]

    for j in Indx[0]:
        if Valmin <= Serie[j]:
          Serie[Serie==Serie[j]] = Valmin

  #-----------------------------------------------------------------------------
  #Writing zeros
  newSerie = np.array(Serie)
  for i in range(Serie.shape[0]):
    if i != 0 and i != Serie.shape[0]-1:
      if Serie[i-1]!=Serie[i] and Serie[i]!=Serie[i+1]:
        newSerie[i]=0
    if i==0:
      if (Serie[i]!=Serie[i+1] and Serie[i]!=Serie[Serie.shape[0]-1]) and np.count_nonzero(Serie == Serie[i])==1:
        newSerie[i]=0
    if i==Serie.shape[0]-1:
      if (Serie[i]!=Serie[i-1] and Serie[i]!=Serie[0]) and np.count_nonzero(Serie == Serie[i])==1:
        newSerie[i]=0
  for i in newSerie:
    if np.count_nonzero(newSerie == i) <= 4:
    #if np.count_nonzero(newSerie == i) <= 3:
    #if np.count_nonzero(newSerie == i) <= 2:
      newSerie[np.where(newSerie == i)] = 0
        

  #-----------------------------------------------------------------------------
  #Writing continuous number's sequence
  sort = 1
  Ser = np.sort(newSerie)
  S = np.unique(Ser)
  for i in S:
    if i != 0:
      newSerie = np.where(newSerie == i, sort, newSerie)
      sort = sort+1

  if visu is not None:
    print('\n-----------Symbolic serie-----------')
    print(newSerie)
    if back_file is not None:
      while(True):
        rep = input("Do you want to save this symbolic series ? (Y/n): ")
        if rep.lower() == 'y':
          newSerie_array = np.array(list(newSerie))
          with open(back_file, 'a') as fichier:
            fichier.write('\n-----------Symbolic serie-----------' + '\n')
            np.savetxt(fichier, newSerie_array, fmt='%d', delimiter='\t', newline='\n', header='', footer='', comments='')
          print(f"Symbolic serie has been successfully saved in {back_file}")
          break
        elif rep.lower() == 'n':
          break
    else :
      while(True):
        rep = input("Do you want to save this symbolic series ? (Y/n): ")
        if rep.lower() == 'y':
          while True:
            name_file = input("Please, give a name to your backup file: ")
            if not os.path.exists(f'{name_file}'):
              break
            else:
                rep2 = input(f"The file '{name_file}' already exists. Do you want to replace it ? (Y/n): ")
            if rep2.lower() == 'y':
              with open(name_file, 'w') as fichier:
                fichier.write('\n-----------Symbolic serie-----------' + '\n')
              np.savetxt(fichier, newSerie_array, fmt='%d', delimiter='\t', newline='\n', header='', footer='', comments='')
              print(f"Symbolic serie has been successfully saved in {name_file}")
              break
            else:
              rep3 = input(f"Do you want to add your serie in it ? (Y/n): ")
            if rep3.lower() == 'y':
              with open(name_file, 'a') as fichier:
                fichier.write('\n-----------Symbolic serie-----------' + '\n')
              np.savetxt(fichier, newSerie_array, fmt='%d', delimiter='\t', newline='\n', header='', footer='', comments='')
              print(f"Symbolic serie has been successfully saved in {name_file}")
              break
          break
        elif rep.lower() == 'n':
          break

  return newSerie

def colored_sym_serie(serie, y, register=None):
  y = np.array(y)
  position = 0
  palette = ['red', 'blue', 'yellow', 'green', 'purple', 'orange', 'black', 'pink', 'brown', 'gray', 'turquoise', 'indigo', 'beige', 'olive', 'cyan', 'magenta', 'gold', 'silver', 'coral', 'lavender', 'chartreuse', 'orangered', 'aquamarine', 'skyblue', 'pumpkin', 'emerald']

  if len(palette) > np.max(serie):
    fig, ax = plt.subplots()
    ax.set_title("Symbolic sequence")
    for couleur in serie:
      ax.barh(y=0, width=1, color=palette[int(couleur)], height=0.2, left=position)
      position += 1

    ax.set_ylim(0, 0.3)
    ax.axis('off')
    
    
    ax2 = ax.twiny()
    ax2.set_xlim(ax.get_xlim())
    ax2.set_ylim(ax.get_ylim())
    ax2.set_xticks(np.arange(0, len(serie) + 1, int(len(serie)/10)))
    ax2.set_xticklabels(np.arange(0, len(serie) + 1, int(len(serie)/10)))
    ax2.tick_params(axis='x', which='both', bottom=True, top=False, labeltop = False, labelbottom=True)
    ax2.set_xlabel('Samples')
    ax2.xaxis.set_label_position('bottom')
    ax.text(int(serie.shape[0])/2, 0.25,"Red: transient state / Other colors: metastable states", fontsize=9, ha='center', va='center')

    plt.show(block=False)
    if(register != None):
      print('\n-----------Colored symbolic serie-----------')
      while(True):
        rep = input("Do you want to save this colored symbolic serie plot ? (Y/n): ")
        if rep.lower() == 'y':
          while True:
            name_file = input("Please, give a name to your plot: ")
            if not os.path.exists(f'{name_file}.png'):
              break
            else:
                rep2 = input(f"The file '{name_file}.png' already exists. Do you want to replace it ? (Y/n): ")
            if rep2.lower() == 'y':
              break
          plt.savefig(f'{name_file}.png')
          print("Colored symbolic serie plot has been successfully saved")
          break
        elif rep.lower() == 'n':
          break
  else:
    print("Your data is too complexe to plot the colored symbolic serie")

def plot_col_traj(serie, y):
  y = np.array(y)

  palette = ['red', 'blue', 'yellow', 'green', 'purple', 'orange', 'black', 'pink', 'brown', 'gray', 'turquoise', 'indigo', 'beige', 'olive', 'cyan', 'magenta', 'gold', 'silver', 'coral', 'lavender', 'chartreuse', 'orangered', 'aquamarine', 'skyblue', 'pumpkin', 'emerald']
  if len(palette) > np.max(serie) :
    if y.shape[1] == 3 :
      figure = plt.figure()
      plt.title("Colored 3D trajectory")
      plt.axis('off')
      ax = figure.add_subplot(111, projection='3d')
      ax.scatter(y[0, 0],y[0,1],y[0,2], color=palette[int(serie[0])], marker='o')
      for i in range(serie.shape[0]-1):
        ax.scatter(y[i+1, 0],y[i+1,1],y[i+1,2], color=palette[int(serie[i+1])], marker='o')
        if serie[i+1]==0:
          ax.plot(y[i:i+2, 0],y[i:i+2,1],y[i:i+2,2], color='red')
        else:
          ax.plot(y[i:i+2, 0],y[i:i+2,1],y[i:i+2,2], color=palette[int(serie[i])])
      ax.text2D(0.5, -0.1, "Red: transient state / Other colors: metastable states", transform=ax.transAxes, fontsize=9, ha='center', va='center')
      ax.set_xlabel('X')
      ax.set_ylabel('Y')
      ax.set_zlabel('Z')

      figure2 = plt.figure()
      ax1 = plt.subplot2grid((2, 2), (0, 0))
      ax2 = plt.subplot2grid((2, 2), (0, 1), rowspan=2)
      ax3 = plt.subplot2grid((2, 2), (1, 0))
      ax1.set_title("Colored 2D trajectory (Y,X)")
      ax1.scatter(y[0, 1],y[0,0], color=palette[int(serie[0])], marker='o')
      for i in range(serie.shape[0]-1):
          ax1.scatter(y[i+1, 1],y[i+1,0], color=palette[int(serie[i+1])], marker='o')
          if serie[i+1]==0:
              ax1.plot(y[i:i+2,1],y[i:i+2,0], color='red')
          else:
              ax1.plot(y[i:i+2,1],y[i:i+2,0], color=palette[int(serie[i])])
      ax1.set_xlabel('Right-Left (Y) axis')
      ax1.set_ylabel('Front-Back (X) axis')
      ax2.set_title("Colored 2D trajectory (X,Z)")
      ax2.scatter(y[0, 0],y[0,2], color=palette[int(serie[0])], marker='o')
      for i in range(serie.shape[0]-1):
          ax2.scatter(y[i+1, 0],y[i+1,2], color=palette[int(serie[i+1])], marker='o')
          if serie[i+1]==0:
              ax2.plot(y[i:i+2, 0],y[i:i+2,2], color='red')
          else:
              ax2.plot(y[i:i+2, 0],y[i:i+2,2], color=palette[int(serie[i])])
      ax2.set_xlabel('Front-Back (X) axis')
      ax2.set_ylabel('Up-Down (Z) axis')
      ax3.set_title("Colored 2D trajectory (Y,Z)")
      ax3.scatter(y[0, 1],y[0,2], color=palette[int(serie[0])], marker='o')
      for i in range(serie.shape[0]-1):
          ax3.scatter(y[i+1, 1],y[i+1,2], color=palette[int(serie[i+1])], marker='o')
          if serie[i+1]==0:
              ax3.plot(y[i:i+2, 1],y[i:i+2,2], color='red')
          else:
              ax3.plot(y[i:i+2, 1],y[i:i+2,2], color=palette[int(serie[i])])
      ax3.set_xlabel('Right-Left (Y) axis')
      ax3.set_ylabel('Up-Down (Z) axis')
      plt.tight_layout()
      plt.show(block=False)
  
    elif y.shape[1] == 2:
      figure = plt.figure()
      plt.scatter(y[0,0], y[0,1], color=palette[int(serie[0])], marker = 'o')
      for i in range(serie.shape[0]-1):
        plt.scatter(y[i+1,0], y[i+1,1], color=palette[int(serie[i+1])], marker = 'o')
        plt.plot(y[i:i+2,0], y[i:i+2,1], color = palette[int(serie[i])])
      plt.text(0.5, -0.1, "Red: transient state / Other colors: metastable states", transform=plt.gca().transAxes, fontsize=9, ha='center', va='center')
      plt.xlabel('Coordinate 1')
      plt.ylabel('Coordinate 2')
    elif y.shape[1] == 1:
      figure = plt.figure()
      for i in range(serie.shape[0]):
        plt.scatter(y[i], 0, color=palette[int(serie[i])], marker='o')

    plt.show(block=False)
  else :
    print("Your data is too complexe to color a trajectory")

  print('\n-----------Colored trajectory-----------')
  while(True):
    rep = input("Do you want to save this colored trajectory ? (Y/n): ")
    if rep.lower() == 'y':
      while True:
        name_file = input("Please, give a name to your plot: ")
        if not os.path.exists(f'{name_file}.png'):
          break
        else:
            rep2 = input(f"The file '{name_file}.png' already exists. Do you want to replace it ? (Y/n): ")
        if rep2.lower() == 'y':
          break
      figure.savefig(f'{name_file}.png')
      if y.shape[1]==3:
        figure2.savefig(f'{name_file}_2D.png')
      print("Colored trajectory has been successfully saved")
      break
    elif rep.lower()=='n':
       break


def complexity(y, xy, serie, visu=None, back_file=None):
    score=None
    regularity=None
    # Alphabet size
    C_alphabet_size = np.max(serie)+1
    if visu != None:
      print('\n------------- Complexity with the alphabet size method -------------')
      print('Complexity alphabet size = ' + str(C_alphabet_size))

    # Number of words
    a = 0
    b = 0
    W_nw = []

    for i in range(len(serie)-1):
        w = ''
        if serie[i] != serie[i+1]:
            for j in range(a, i+1, 1):
                w = w + str(int(serie[j]))
            W_nw.append(w)
            a = i + 1
        if i == len(serie)-2:
            for j in range(a, i+2, 1):
                w = w + str(int(serie[j]))
            W_nw.append(w)
    unique = set(W_nw)
    C_nbr_words = len(unique)

    if visu != None:
      print('\n------------- Complexity with the number of words method -------------')
      print('Complexity number of words = ' + str(C_nbr_words))

    # Lempel-Ziv

    def pattern_in_serie(w, s):
      w_str = ''
      s_str = ''
      for a in w:
        w_str=w_str+str(a)
      for b in s:
        s_str = s_str+str(b)
      return s_str in w_str

    C_LZ = 0
    i = 0
    W_LZ = []
    W_LZ.append(serie[i])
    i = 1
    while i < len(serie):
        j = i
        Bool = pattern_in_serie(W_LZ[:j], str(serie[j]))
        if Bool == False:
            W_LZ.append(str(serie[i]))
            i = i + 1
        else:
            while Bool == True:
                j = j + 1
                if j >= len(serie):
                    break
                Bool = pattern_in_serie(W_LZ[:j], serie[i:j + 1])
            W_LZ.append(''.join(map(str, serie[i:j + 1])))
            i = j + 1

    C_LZ = len(W_LZ)

    if visu != None:
      print('\n------------- Complexity with the Lempel-Ziv method -------------')
      print('Complexity Lempel-Ziv = ' + str(C_LZ))
      print('\n----------------- Correspondance with healty gait -----------------')
      score = correspondance(serie, y, xy)
      print('\n------------------------ Regularity score ------------------------')
      regularity,regu,moyetype = regularity_score(serie, visu)
      print('\n')
      if back_file is not None:
        while(True):
          rep = input("Do you want to save this complexity measures ? (Y/n): ")
          if rep.lower() == 'y':
            with open(back_file, 'a') as fichier:
              fichier.write('\n------------- Complexity with the alphabet size method -------------\n')
              fichier.write('Complexity alphabet size = ' + str(C_alphabet_size))
              fichier.write('\n------------- Complexity with the number of words method -------------\n')
              fichier.write('Complexity number of words = ' + str(C_nbr_words))
              fichier.write('\n------------- Complexity with the Lempel-Ziv method -------------\n')
              fichier.write('Complexity Lempel-Ziv = ' + str(C_LZ) + '\n')
              fichier.write('\n------------- Correspondance with healty gait -------------\n')
              fichier.write('Correspondance score = ' + str(score) + '%\n')
              fichier.write('\n------------------------ Regularity score ------------------------\n')
              fichier.write('Regularity score = ' + str(round(regularity,2)) + '%\n')
            print(f"Complexity measures have been successfully saved in {back_file}")
            break
          elif rep.lower() == 'n':
             break
      else :
        while(True):
          rep = input("Do you want to save this complexity measures ? (Y/n): ")
          if rep.lower() == 'y':
            while True:
              name_file = input("Please, give a name to your backup file: ")
              if not os.path.exists(f'{name_file}'):
                break
              else:
                  rep2 = input(f"The file '{name_file}' already exists. Do you want to replace it ? (Y/n): ")
              if rep2.lower() == 'y':
                with open(name_file, 'w') as fichier:
                  fichier.write('\n------------- Complexity with the alphabet size method -------------\n')
                  fichier.write('Complexity alphabet size = ' + str(C_alphabet_size))
                  fichier.write('\n------------- Complexity with the number of words method -------------\n')
                  fichier.write('Complexity number of words = ' + str(C_nbr_words))
                  fichier.write('\n------------- Complexity with the Lempel-Ziv method -------------\n')
                  fichier.write('Complexity Lempel-Ziv = ' + str(C_LZ) + '\n')
                  fichier.write('\n------------- Correspondance with healty gait -------------\n')
                  fichier.write('Correspondance score = ' + str(score) + '%\n')
                  fichier.write('\n------------------------ Regularity score ------------------------\n')
                  fichier.write('Regularity score = ' + str(round(regularity,2)) + '%\n')
                print(f"Complexity measures have been successfully saved in {name_file}")
                break
              else:
                rep3 = input(f"Do you want to add your complexity measures in it ? (Y/n): ")
              if rep3.lower() == 'y':
                with open(name_file, 'a') as fichier:
                  fichier.write('\n------------- Complexity with the alphabet size method -------------\n')
                  fichier.write('Complexity alphabet size = ' + str(C_alphabet_size))
                  fichier.write('\n------------- Complexity with the number of words method -------------\n')
                  fichier.write('Complexity number of words = ' + str(C_nbr_words))
                  fichier.write('\n------------- Complexity with the Lempel-Ziv method -------------\n')
                  fichier.write('Complexity Lempel-Ziv = ' + str(C_LZ)+ '\n')
                  fichier.write('\n------------- Correspondance with healty gait -------------\n')
                  fichier.write('Correspondance score = ' + str(score) + '%\n')
                  fichier.write('\n------------------------ Regularity score ------------------------\n')
                  fichier.write('Regularity score = ' + str(round(regularity,2)) + '%\n')
                print(f"Complexity measures have been successfully saved in {name_file}")
                break
            break
          elif rep.lower() == 'n':
            break

    return C_alphabet_size, C_nbr_words, C_LZ, score, regularity


def complexity_shuffle(y, xy, step, count=100, back_file = None):
  y2 = y
  alphabet = []
  words= []
  lempelZiv = []

  epsi = opti_epsi.epsi_entropy(y,step)
  R = recurrence.rec_mat(y, epsi)
  serie = symbolic_serie(R)
  alpha, word, lz, score, regularity = complexity(y, xy,serie)
  alphabet.append(alpha)
  words.append(word)
  lempelZiv.append(lz)

  for i in range(count):
    np.random.shuffle(y2)
    epsi = opti_epsi.epsi_entropy(y2,step)
    R = recurrence.rec_mat(y2, epsi)
    serie = symbolic_serie(R)
    alpha, word, lz, regularity = complexity(y, xy,serie)
    alphabet.append(alpha)
    words.append(word)
    lempelZiv.append(lz)
    sys.stdout.write("\r")
    sys.stdout.write(f"Test n°: {i+1}/{count}")
    sys.stdout.flush()



  fig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(8, 20))
  plt.subplots_adjust(hspace=1.0)
  ord = [2] * (count+1)
  ax1.plot(alphabet[0],0, marker='o', color='red', label='First value', linestyle='None')  
  ax1.plot(alphabet[1:], range(1, count + 1), marker='.', color='blue', linestyle='None', label='Shuffled values')
  ax2.plot(words[0],0, marker='o', color='red', label='First value', linestyle='None')
  ax2.plot(words[1:], range(1, count + 1), marker='.', color='blue', linestyle='None', label='Shuffled values')
  ax3.plot(lempelZiv[0],0, marker='o', color='red', label='First value', linestyle='None')
  ax3.plot(lempelZiv[1:],range(1, count + 1), marker='.', color='blue', linestyle='None', label='Shuffled values')
  ax1.set_title('Alphabet Size Complexity')
  ax2.set_title('Number of Words Complexity')
  ax3.set_title('Lempel-Ziv Complexity')
  ax1.set_xlabel('Complexity values')
  ax1.set_ylabel('Iteration n°')
  ax2.set_xlabel('Complexity values')
  ax2.set_ylabel('Iteration n°')
  ax3.set_xlabel('Complexity values')
  ax3.set_ylabel('Iteration n°')
  ax1.legend()
  ax2.legend()
  ax3.legend()

  #plt.tight_layout()
  plt.show(block=False)

  ocAlpha = {}
  ocWords = {}
  ocLZ = {}

  for v in alphabet:
      if v in ocAlpha:
          ocAlpha[v] += 1
      else:
          ocAlpha[v] = 1

  for v in words:
      if v in ocWords:
          ocWords[v] += 1
      else:
          ocWords[v] = 1

  for v in lempelZiv:
      if v in ocLZ:
          ocLZ[v] += 1
      else:
          ocLZ[v] = 1

  width = 0.35

  fig2, (ax4,ax5,ax6) = plt.subplots(3, 1, figsize=(8, 16))
  plt.subplots_adjust(hspace=0.8)
  bars1 = ax4.bar(ocAlpha.keys(), ocAlpha.values(), width)
  bars2 = ax5.bar(ocWords.keys(), ocWords.values(), width)
  bars3 = ax6.bar(ocLZ.keys(), ocLZ.values(), width)


  index_alpha = list(ocAlpha.keys()).index(alphabet[0])
  index_words = list(ocWords.keys()).index(words[0])
  index_lz = list(ocLZ.keys()).index(lempelZiv[0])

  bars1[index_alpha].set_color('red')
  bars2[index_words].set_color('red')
  bars3[index_lz].set_color('red')

  ax4.set_title('Alphabet Size Complexity')
  ax5.set_title('Number of Words Complexity')
  ax6.set_title('Lempel-Ziv Complexity')
  ax4.set_xticks(list(ocAlpha.keys()))
  ax5.set_xticks(list(ocWords.keys()))
  ax6.set_xticks(list(ocLZ.keys()))
  ax4.set_xlabel('Complexity values')
  ax4.set_ylabel('Population')
  ax5.set_xlabel('Complexity values')
  ax5.set_ylabel('Population')
  ax6.set_xlabel('Complexity values')
  ax6.set_ylabel('Population')
  ax6.text(0.1, -0.3, "Red bar: Contains the first complexity value", transform=ax6.transAxes, fontsize=9, ha='center', va='center')
  plt.show(block=False)

  print("\n\n-----------T-test non-parametric Wilcoxon-Mann-Whitney-----------")
  u_statistic_alpha, p_value_alpha = mannwhitneyu(alphabet[1:], [alphabet[0]])
  print("\np value Alphabet Size for ",alphabet[0]," = ",p_value_alpha)
  if p_value_alpha < 0.1:
      display_ya = "Alphabet Size Complexity measure is far from the random distribution. Results can be interpreted."
      print(display_ya)
      backa = display_ya
  else:
      display_na = "Alphabet Size Complexity measure is too close to the random distribution. Results cannot be interpreted."
      print(display_na)
      backa = display_na

  u_statistic_words, p_value_words = mannwhitneyu(words[1:], [words[0]])
  print("\np value Number of Words for ",words[0]," = ",p_value_words)
  if p_value_words < 0.1:
      display_yw = "Number of Words Complexity measure is far from the random distribution. Results can be interpreted."
      print(display_yw)
      backw = display_yw
  else:
      display_nw = "Number of Words Complexity measure is too close to the random distribution. Results cannot be interpreted."
      print(display_nw)
      backw = display_nw

  u_statistic_lz, p_value_lz = mannwhitneyu(lempelZiv[1:], [lempelZiv[0]])
  print("\np value Lempel-Ziv for ",lempelZiv[0]," = ",p_value_lz)
  if p_value_lz < 0.1:
      display_yl = "Lempel-Ziv Complexity measure is far from the random distribution. Results can be interpreted."
      print(display_yl)
      backl = display_yl
  else:
      display_nl = "Lempel-Ziv Complexity measure is too close to the random distribution. Results cannot be interpreted."
      print(display_nl)
      backl = display_nl


  print('\n-----------Complexity analysis-----------')
  while(True):
    rep = input("Do you want to save this analysis ? (Y/n): ")
    if rep.lower() == 'y':
      while True:
        name_file = input("Please, give a name to your plot: ")
        if not os.path.exists(f'{name_file}.png'):
          break
        else:
            rep2 = input(f"The file '{name_file}.png' already exists. Do you want to replace it ? (Y/n): ")
        if rep2.lower() == 'y':
          break
      fig.savefig(f'{name_file}_dot.png')
      fig2.savefig(f'{name_file}_bar.png')

      if back_file != None:
        with open(back_file, 'a') as fichier:
          fichier.write('\n------------- Mann Withney U T-Test -------------\n')
          fichier.write(f'\nP value for Alphabet Size = {p_value_alpha}')
          fichier.write(backa)
          fichier.write(f'\nP value for Number of Words = {p_value_words}')
          fichier.write(backw)
          fichier.write(f'\nP value for Lempel-Ziv: {p_value_lz}')
          fichier.write(backl)
        print(f"T-test results have been successfully saved in {back_file}")
      else: 
        while True:
          name_file = input("Please, give a name to your backup file: ")
          if not os.path.exists(f'{name_file}'):
            a=0
            break
          else:
            rep3 = input(f"The file '{name_file}' already exists. Do you want to write your t-test results inside? (Y/n): ")
            if rep3.lower() == 'y':
              a=1
              break
            else:
              rep4 = input(f"Do you want to replace '{name_file}'? (Y/n): ")
              if rep4.lower() == 'y':
                a=2
                break
        if a == 0 or a == 2:
          with open(name_file, 'w') as fichier:
            fichier.write('\n\n------------- Mann Withney U T-Test -------------\n')
            fichier.write(f'\nP value for Alphabet Size = {p_value_alpha}\n')
            fichier.write(backa)
            fichier.write(f'\nP value for Number of Words = {p_value_words}\n')
            fichier.write(backw)
            fichier.write(f'\nP value for Lempel-Ziv: {p_value_lz}\n')
            fichier.write(backl)
          print(f"T-test results have been successfully saved in {name_file}")
        if a == 1:
          with open(name_file, 'a') as fichier:
            fichier.write('\n------------- Mann Withney U T-Test -------------\n')
            fichier.write(f'\nP value for Alphabet Size = {p_value_alpha}')
            fichier.write(backa)
            fichier.write(f'\nP value for Number of Words = {p_value_words}')
            fichier.write(backw)
            fichier.write(f'\nP value for Lempel-Ziv: {p_value_lz}')
            fichier.write(backl)
          print(f"T-test results have been successfully saved in {name_file}")

      print("Complexity analysis has been successfully saved")
      break
    elif rep.lower() == 'n':
      break

def nbr_state(serie):
    serie = serie.astype(int)
    s = np.unique(serie)
    dic_nbr = {}
    dic_loc = {}
    for i in range(1,len(s)):
        dic_nbr[str(i)] = 0
        dic_loc[str(i)] = []
    for i in range(len(serie)-1):
        if serie[i]!=0:
          dic_loc[str(serie[i])].append(i)
        if serie[i] != serie[i+1] and serie[i]!=0:
            dic_nbr[str(serie[i])]=dic_nbr[str(serie[i])]+1
        if i == len(serie)-2 and serie[i]==serie[i+1] and serie[i]!=0:
            dic_nbr[str(serie[i])]=dic_nbr[str(serie[i])]+1
            dic_loc[str(serie[i])].append(i)
        elif i == len(serie)-2 and serie[i]!=serie[i+1]and serie[i+1]!=0:
            dic_nbr[str(serie[i+1])]=dic_nbr[str(serie[i+1])]+1
            dic_loc[str(serie[i+1])].append(i+1)
    return dic_nbr,dic_loc

def reco_state(serie,y):
  dic_nbr,dic_loc = nbr_state(serie)
  dic_state = {}
  miniz = np.min(y[:,2])
  maxiz = np.max(y[:,2])
  minix = np.min(y[:,0])
  maxix = np.max(y[:,0])
  tier_min_z = miniz+1/5*(maxiz-miniz)
  tier_x = minix + (maxix+minix)/3
  print(dic_loc)
  for j in range(1,len(dic_nbr)+1):
    p=0
    for i in dic_loc[str(j)]:
      if y[i,2] < tier_min_z and y[i,0] > tier_x:
        p = p+0
      elif y[i,2] > tier_min_z or y[i,0] < tier_x:
        p = p+1
    p=p/len(dic_loc[str(j)])
    if abs(p-1)<abs(p):
      state = 'max'
    else:
      state ='min'
    dic_state[str(j)] = state
  return dic_state

"""def correspondance(serie, y, xy):
    serie = np.array(serie)
    serie = serie.astype(int)
    xy = np.array(xy)
    serie.astype(int)
    xy.astype(int)
    maxpeak,minpeak = opti_epsi.nbr_peaks(xy)
    dic,dic_loc = nbr_state(serie)
    dic_state = reco_state(serie,xy)

    score = 0
    sc_etat = 0
    sc_min = 0
    sc_max = 0
    sc_alpha = 0
    sc_peak = 0
    etat=0
    maxmin=0

    if 'max' in dic_state.values() and 'min' in dic_state.values():
       maxmin = 1
    else:
       maxmin = 0

    i=0
    while(i<len(serie)):
        corresp=0
        prem=i
        if str(serie[i]) in dic_state and dic_state[str(serie[i])]=='max':
            etat=etat+1
            if i<len(serie)-1 and serie[i]==serie[i+1]:
                while(i<len(serie)-1 and serie[i]==serie[i+1]):
                    if xy[i,0]>(np.max(xy[:,0])+np.min(xy[:,0]))/2 and xy[i,2]>xy[i+1,2]:
                        corresp = corresp+1
                    i=i+1
                if i<len(serie)-1 and serie[i]!=serie[i+1]:
                    if xy[i,0]>(np.max(xy[:,0])+np.min(xy[:,0]))/2 and xy[i,2]>xy[i+1,2]:
                        corresp = corresp+1
                if i == len(serie)-1:
                    if xy[i,0]>(np.max(xy[:,0])+np.min(xy[:,0]))/2:
                        corresp = corresp+1
            elif i<len(serie)-1:
                if xy[i,0]>(np.max(xy[:,0])+np.min(xy[:,0]))/2 and xy[i,2]>xy[i+1,2]:
                    corresp = corresp+1
            elif i==len(serie)-1:
                if xy[i,0]>(np.max(xy[:,0])+np.min(xy[:,0]))/2:
                    corresp = corresp+1

        elif str(serie[i]) in dic_state and dic_state[str(serie[i])]=='min':
            etat=etat+1
            if i<len(serie)-1 and serie[i]==serie[i+1]:
                while(i<len(serie)-1 and serie[i]==serie[i+1]):
                    if xy[i,0]<(np.max(xy[:,0])-np.min(xy[:,0]))*0.8+np.min(xy[:,0]) and xy[i,2]<(np.max(xy[:,2])-np.min(xy[:,2]))*0.8+np.min(xy[:,2]):
                        corresp = corresp+1
                    i=i+1
                if i<len(serie)-1 and serie[i]!=serie[i+1]:
                    if xy[i,0]<(np.max(xy[:,0])-np.min(xy[:,0]))*0.8+np.min(xy[:,0]) and xy[i,2]<(np.max(xy[:,2])-np.min(xy[:,2]))*0.8+np.min(xy[:,2]):
                        corresp = corresp+1
                if i == len(serie)-1:
                    if xy[i,0]<(np.max(xy[:,0])-np.min(xy[:,0]))*0.8+np.min(xy[:,0]) and xy[i,2]<(np.max(xy[:,2])-np.min(xy[:,2]))*0.8+np.min(xy[:,2]):
                        corresp = corresp+1
            else:
                if xy[i,0]<(np.max(xy[:,0])-np.min(xy[:,0]))*0.8+np.min(xy[:,0]) and xy[i,2]<(np.max(xy[:,2])-np.min(xy[:,2]))*0.8+np.min(xy[:,2]):
                    corresp = corresp+1    
        der = i+1
        if corresp > (der-prem)*0.5:
            sc_etat = sc_etat+1
        i=i+1
  
    score = score + sc_etat/etat
    nbr_min = 0
    nbr_max = 0
    for i in range(1,len(dic_state)+1):
        if dic_state[str(i)] == 'min':
            nbr_min = nbr_min+dic[str(i)]
        if dic_state[str(i)] == 'max':
            nbr_max = nbr_max+dic[str(i)]

    sc_max = 1-abs(nbr_max-maxpeak)/max(nbr_max, maxpeak)
    sc_min = 1-abs(nbr_min-minpeak)/max(nbr_min, minpeak)
    sc_peak = (sc_max+sc_min)/2

    C_alpha,C_word,C_LZ_test,sco,regularity=complexity(y,xy,serie)
    sc_alpha = ((1-abs(C_alpha-3)/max(C_alpha,3))+maxmin)/2
    score = score+sc_alpha
    score= score+sc_peak
    score=score/3
    score=round(score*100,2)
    
    print("\nScore state xz : ",round(sc_etat/etat,2))
    #print("sc_max = 1-abs(",nbr_max,"-",maxpeak,")/",max(nbr_max, maxpeak))
    print("Score peak max : ",round(sc_max,2))
    #print("sc_max = 1-abs(",nbr_min,"-",minpeak,")/",max(nbr_min, minpeak))
    print("Score peak min : ",round(sc_min,2))
    print("Score alphabet size complexity : ",round(sc_alpha,2))
    print("\nThe correspondance with a healthy gait is : ",score,"%")
    
    return score"""

def regularity_score(serie, visu=None):
  serie = np.array(serie)
  serie = serie.astype(int)
  a_size_des = 3
  a_size_reel = len(np.unique(serie))
  a_size = abs((a_size_reel-a_size_des)/a_size_des)*100
  if visu!=None:
    print("Alphabet size = ",a_size)
  
  lines = len(np.unique(serie))
  nbr_symb=np.zeros(lines)
  order = []
  for i in range(len(serie)-1):
    if i == 0:
        nbr_symb[serie[i]] = nbr_symb[serie[i]]+1
        order.append(serie[i])
    if serie[i]!=serie[i+1]:
        nbr_symb[serie[i+1]] = nbr_symb[serie[i+1]]+1
        order.append(serie[i+1])
  nbr_symb = nbr_symb.astype(int)
  if visu!=None:
    print("Number of symbols = ",nbr_symb)

  oc=[]
  for i in np.unique(order):
    oc.append(order.count(i))
  size_words = []
  for i in range(len(oc)):
    size_words.append([0] * oc[i])  
  j=0
  c=0
  for i in range(len(serie)-1):
    size_words[serie[i]][j] = size_words[serie[i]][j]+1
    if serie[i]!=serie[i+1]:
      if c==0:
        del size_words[serie[i]][0]
      c=c+1
      j=0
      while(j<len(size_words[serie[i+1]])):
        if size_words[serie[i+1]][j]==0:
          break
        else:
          j=j+1
    if i==len(serie)-2:
      del size_words[serie[i+1]][-1]
  del size_words[0]
  etype=[]
  #longu=[]
  for i in range(len(size_words)):
    if size_words[i]!=[]:
      ecarttype = np.std(size_words[i])
      moyenne = np.mean(size_words[i])
      #long = moyenne*nbr_symb[i+1]/len(serie)
      #longu.append(abs((long-(1/len(nbr_symb)))/(1/len(nbr_symb)))*100)
      etype.append((ecarttype/moyenne)*100)

  moyetype = round(np.mean(etype),2)
  #moylongu = round(np.mean(longu),2)
  #print("\nMean of standard deviation of state lengths = ",moyetype)
  if visu!=None:
    print("Normalized mean of standard deviation of state lengths = ",round(moyetype,2),"%")
  #print("Relative words size error = ",moylongu,"%")

  def pattern_in_serie(w, s):
    w_str = ''
    s_str = ''
    for a in w:
      w_str=w_str+str(a)
    for b in s:
      s_str = s_str+str(b)
    return s_str in w_str
  C_LZ = 0
  i = 0
  W_LZ = []
  W_LZ.append(order[i])
  i = 1
  while i < len(order):
      j = i
      Bool = pattern_in_serie(W_LZ[:j], str(order[j]))
      if Bool == False:
          W_LZ.append(str(order[i]))
          i = i + 1
      else:
          while Bool == True:
              j = j + 1
              if j >= len(order):
                  break
              Bool = pattern_in_serie(W_LZ[:j], order[i:j + 1])
          W_LZ.append(''.join(map(str, order[i:j + 1])))
          i = j + 1
  C_LZ = len(W_LZ)
  #print("\nRegularity of the states sequence = ",C_LZ)

  ideal=[]
  s=[]
  l=len(np.unique(order))
  le = len(order)
  prem = order[0]
  cou=0
  for i in range(2*l-2):
    if prem == 0:
      if i%2==0:
        s.append(0)
      else:
        cou=cou+1
        s.append(cou)
    else:
      if i%2==0:
        cou=cou+1
        s.append(cou)
      else:
        s.append(0)

  for i in range(le):
    ideal.append(s[i%len(s)])

  C_LZi = 0
  ii = 0
  W_LZi = []
  W_LZi.append(ideal[ii])
  ii = 1
  while ii < len(ideal):
      ji = ii
      Booli = pattern_in_serie(W_LZi[:ji], str(ideal[ji]))
      if Booli == False:
          W_LZi.append(str(ideal[ii]))
          ii = ii + 1
      else:
          while Booli == True:
              ji = ji + 1
              if ji >= len(ideal):
                  break
              Booli = pattern_in_serie(W_LZi[:ji], ideal[ii:ji + 1])
          W_LZi.append(''.join(map(str, ideal[ii:ji + 1])))
          ii = ji + 1
  C_LZi = len(W_LZi)
  regu = abs((C_LZ-C_LZi)/C_LZi)*100
  if visu!=None:
    print("Normalized regularity of the states sequence = ",round(regu,2),"%")
  print(ideal)
  print(order)
  #regularity=(regu+moyetype+moylongu)/3
  regularity=(regu+moyetype+a_size)/3
  if visu!=None:
    print("\nThe regularity score of the gait is = ",round(regularity,2),"\n\n")
  return regularity,regu,moyetype

def regularity_shuffle(regularity1, serie, back_file=None):

  fig1=plt.figure()
  ax1 = fig1.add_subplot(111)
  ax1.set_title('Total Regularity Score')
  ax1.scatter(0,regularity1, color='red', marker='o')

  serie2 = serie.copy()
  regularity=regu=moyetype=[]

  for i in range(100):
    np.random.shuffle(serie2)
    r1,r2,m1 = regularity_score(serie2)
    regularity.append(r1)
    regu.append(r2)
    moyetype.append(m1)

  lin=np.linspace(1, len(regularity), len(regularity))
  ax1.scatter(lin,regularity, color='blue', marker='o')
  plt.show(block=False)
  print("\n\n-----------T-test non-parametric Wilcoxon-Mann-Whitney-----------")
  u_statistic_alpha, p_value = mannwhitneyu(regularity, [regularity1])
  if p_value<=0.1:
    print("P value = ",p_value," <= 0.1")
    print("T Test is valid")
  else:
    print("P value = ",p_value," > 0.1")
    print("T Test invalide, data is not representative")

  print('\n-----------Regularity analysis-----------')
  while(True):
    rep = input("Do you want to save this analysis ? (Y/n): ")
    if rep.lower() == 'y':
      while True:
        name_file = input("Please, give a name to your plot: ")
        if not os.path.exists(f'{name_file}.png'):
          break
        else:
            rep2 = input(f"The file '{name_file}.png' already exists. Do you want to replace it ? (Y/n): ")
        if rep2.lower() == 'y':
          break
      fig1.savefig(f'{name_file}_dot.png')
      if back_file != None:
        with open(back_file, 'a') as fichier:
          fichier.write('\n------------- Mann Withney U T-Test -------------\n')
          fichier.write(f'\nP value for Alphabet Size = {p_value}')
      else: 
        while True:
          name_file = input("Please, give a name to your backup file: ")
          if not os.path.exists(f'{name_file}'):
            a=0
            break
          else:
            rep3 = input(f"The file '{name_file}' already exists. Do you want to write your t-test results inside? (Y/n): ")
            if rep3.lower() == 'y':
              a=1
              break
            else:
              rep4 = input(f"Do you want to replace '{name_file}'? (Y/n): ")
              if rep4.lower() == 'y':
                a=2
                break
        if a == 0 or a == 2:
          with open(name_file, 'w') as fichier:
            fichier.write('\n\n------------- Mann Withney U T-Test -------------\n')
            fichier.write(f'\nP value for Alphabet Size = {p_value}\n')
          print(f"T-test results have been successfully saved in {name_file}")
        if a == 1:
          with open(name_file, 'a') as fichier:
            fichier.write('\n------------- Mann Withney U T-Test -------------\n')
            fichier.write(f'\nP value for Alphabet Size = {p_value}')
          print(f"T-test results have been successfully saved in {name_file}")

      print("Complexity analysis has been successfully saved")
      break
    elif rep.lower()== 'n':
      break

def correspondance(serie, y, xy):
    serie = np.array(serie)
    serie = serie.astype(int)
    xy = np.array(xy)
    serie.astype(int)
    xy.astype(int)
    maxpeak,minpeak = opti_epsi.nbr_peaks(xy)
    dic,dic_loc = nbr_state(serie)
    dic_state = reco_state(serie,y)

    score = 0
    sc_etat = 0
    sc_min = 0
    sc_max = 0
    sc_alpha = 0
    sc_peak = 0
    etat=0
    maxmin=0

    if 'max' in dic_state.values() and 'min' in dic_state.values():
       maxmin = 1
    else:
       maxmin = 0

    i=0
    while(i<len(serie)):
        corresp=0
        prem=i
        if str(serie[i]) in dic_state and dic_state[str(serie[i])]=='max':
            etat=etat+1
            if i<len(serie)-1 and serie[i]==serie[i+1]:
                while(i<len(serie)-1 and serie[i]==serie[i+1]):
                    #if xy[i,0]>(np.max(xy[:,0])+np.min(xy[:,0]))/2 and xy[i,2]>xy[i+1,2]:
                    if xy[i,0]>(np.max(xy[:,0])+np.min(xy[:,0]))/2 or xy[i,2]>(4/5*np.min(xy[:,2])+1/5*np.max(xy[:,2])):
                        corresp = corresp+1
                    i=i+1
                if i<len(serie)-1 and serie[i]!=serie[i+1]:
                    if xy[i,0]>(np.max(xy[:,0])+np.min(xy[:,0]))/2 or xy[i,2]>(4/5*np.min(xy[:,2])+1/5*np.max(xy[:,2])):
                        corresp = corresp+1
                if i == len(serie)-1:
                    if xy[i,0]>(np.max(xy[:,0])+np.min(xy[:,0]))/2 or xy[i,2]>(4/5*np.min(xy[:,2])+1/5*np.max(xy[:,2])):
                        corresp = corresp+1
            elif i<len(serie)-1:
                if xy[i,0]>(np.max(xy[:,0])+np.min(xy[:,0]))/2 or xy[i,2]>(4/5*np.min(xy[:,2])+1/5*np.max(xy[:,2])):
                    corresp = corresp+1
            elif i==len(serie)-1:
                if xy[i,0]>(np.max(xy[:,0])+np.min(xy[:,0]))/2 or xy[i,2]>(4/5*np.min(xy[:,2])+1/5*np.max(xy[:,2])):
                    corresp = corresp+1

        elif str(serie[i]) in dic_state and dic_state[str(serie[i])]=='min':
            etat=etat+1
            if i<len(serie)-1 and serie[i]==serie[i+1]:
                while(i<len(serie)-1 and serie[i]==serie[i+1]):
                    if xy[i,0]>(np.max(xy[:,0])-np.min(xy[:,0]))*1/3+np.min(xy[:,0]) and xy[i,2]<(np.max(xy[:,2])-np.min(xy[:,2]))*1/5+np.min(xy[:,2]):
                        corresp = corresp+1
                    i=i+1
                if i<len(serie)-1 and serie[i]!=serie[i+1]:
                    if xy[i,0]<(np.max(xy[:,0])-np.min(xy[:,0]))*1/3+np.min(xy[:,0]) and xy[i,2]<(np.max(xy[:,2])-np.min(xy[:,2]))*1/5+np.min(xy[:,2]):
                        corresp = corresp+1
                if i == len(serie)-1:
                    if xy[i,0]<(np.max(xy[:,0])-np.min(xy[:,0]))*1/3+np.min(xy[:,0]) and xy[i,2]<(np.max(xy[:,2])-np.min(xy[:,2]))*1/5+np.min(xy[:,2]):
                        corresp = corresp+1
            else:
                if xy[i,0]<(np.max(xy[:,0])-np.min(xy[:,0]))*1/3+np.min(xy[:,0]) and xy[i,2]<(np.max(xy[:,2])-np.min(xy[:,2]))*1/5+np.min(xy[:,2]):
                    corresp = corresp+1    
        der = i+1
        if corresp > (der-prem)*0.5:
            sc_etat = sc_etat+1
        i=i+1
  
    score = score + sc_etat/etat
    nbr_min = 0
    nbr_max = 0
    for i in range(1,len(dic_state)+1):
        if dic_state[str(i)] == 'min':
            nbr_min = nbr_min+dic[str(i)]
        if dic_state[str(i)] == 'max':
            nbr_max = nbr_max+dic[str(i)]

    sc_max = 1-abs((nbr_max-maxpeak)/maxpeak)
    sc_min = 1-abs((nbr_min-minpeak)/minpeak)

    C_alpha,C_word,C_LZ_test,sco,regularity=complexity(y,xy,serie)
    sc_alpha = 1-abs((C_alpha-3)/3)
    score = score+sc_alpha + sc_max + sc_min
    regularity,regu,moyetype = regularity_score(serie)
    regu = 1-regu/100
    score = score + regu
    score=score/5
    score=round(score*100,2)
    
    print("\nScore state xz : ",round(sc_etat/etat,2))
    #print("sc_max = 1-abs(",nbr_max,"-",maxpeak,")/",maxpeak,")")
    print(dic," : ", dic_state)
    print("Score peak max : ",round(sc_max,2))
    #print("sc_max = 1-abs(",nbr_min,"-",minpeak,"/",minpeak,")")
    print("Score peak min : ",round(sc_min,2))
    print("Score alphabet size complexity : ",round(sc_alpha,2))
    print("Score regularity : ",round(regu,2))
    print("\nThe correspondance with a healthy gait is : ",score,"%")
    
    return score


def lempel_ziv(serie, visu=None):
  serie = np.array(serie)
  serie = serie.astype(int)

  order = []
  for i in range(len(serie)-1):
    if i == 0:
        order.append(serie[i])
    if serie[i]!=serie[i+1]:
        order.append(serie[i+1])

  def pattern_in_serie(w, s):
    w_str = ''
    s_str = ''
    for a in w:
      w_str=w_str+str(a)
    for b in s:
      s_str = s_str+str(b)
    return s_str in w_str
  
  C_LZ = 0
  i = 0
  W_LZ = []
  W_LZ.append(order[i])
  i = 1
  while i < len(order):
      j = i
      Bool = pattern_in_serie(W_LZ[:j], str(order[j]))
      if Bool == False:
          W_LZ.append(str(order[i]))
          i = i + 1
      else:
          while Bool == True:
              j = j + 1
              if j >= len(order):
                  break
              Bool = pattern_in_serie(W_LZ[:j], order[i:j + 1])
          W_LZ.append(''.join(map(str, order[i:j + 1])))
          i = j + 1
  C_LZ = len(W_LZ)
  C_LZ_n = C_LZ/len(order)
  if visu != None : 
    print("\n\n Regularity of the sequence = ",C_LZ)
    print("Normalized regularity of the sequence = ",C_LZ_n)
  return C_LZ