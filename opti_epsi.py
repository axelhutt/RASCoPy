# -*- coding: utf-8 -*-
"""opti_epsi.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1L0gckCYfD-DhzbvIlU5qZfF1LF_XLT3v
"""

import numpy as np
import math
import matplotlib.pyplot as plt
from scipy.spatial.distance import cdist
import io
import os

def epsi_entropy(y, step):
    y = np.array(y)
    epsi = 0
    D = cdist(y, y, 'euclidean')
    nbr_epsi = int(math.ceil(np.max(D))/step)

    Entropy = np.zeros(nbr_epsi)
    Epsi = np.zeros(nbr_epsi)

    for e in range(nbr_epsi):
        epsi = epsi + step
        R = np.array(D<epsi)
        R=R.astype(int)

        R=np.tril(R)

        #------------------------------------------------------------------------------
        #Rewriting grammar
        Serie=np.zeros((R.shape[1]))

        for i in range(R.shape[1]):
          Serie[i]=i+1

        for i in range(R.shape[0]):
          Indx = np.where(R[R.shape[0]-1-i, :]!=0)
          Valmin = int(Serie[np.min(Indx[0])])
          for j in Indx[0]:
              if Valmin < Serie[j]:
                Serie[Serie==Serie[j]] = Valmin

        #-----------------------------------------------------------------------------
        #Writing zeros
        newSerie = np.array(Serie)
        for i in range(Serie.shape[0]):
          if i != 0 and i != Serie.shape[0]-1:
            if Serie[i-1]!=Serie[i] and Serie[i]!=Serie[i+1]:
              newSerie[i]=0
          if i==0:
            if Serie[i]!=Serie[i+1] and Serie[i]!=Serie[Serie.shape[0]-1]:
              newSerie[i]=0
          if i==Serie.shape[0]-1:
            if Serie[i]!=Serie[i-1] and Serie[i]!=Serie[0]:
              newSerie[i]=0

        #-----------------------------------------------------------------------------
        #Writing continuous number's sequence
        sort = 0
        Ser = np.sort(newSerie)
        S = np.unique(Ser)
        for i in S:
          newSerie = np.where(newSerie == i, sort, newSerie)
          sort = sort+1

        #Entropy
        Serie=newSerie
        Serie = Serie.astype(int)
        p = np.array(np.unique(Serie).shape[0])
        H=0
        occurrences = np.bincount(Serie)
        for valeur, nb_occurrences in enumerate(occurrences):
            if nb_occurrences > 0:
                pi = nb_occurrences/Serie.shape[0]
                H=H+pi*np.log2(pi)

        Hneg = -H
        Entropy[e]= Hneg
        Epsi[e] = epsi

    # Results epsilon
    Hmax = np.max(Entropy)
    IndxHmax = np.argmax(Entropy)
    EpsiOptiH = Epsi[IndxHmax]
    print('\n---------Entropy Optimal Epsilon----------')
    print('Epsilon with maximum Entropy =', round(EpsiOptiH, 3))

    fig = plt.figure()
    plt.plot(Epsi, Entropy)
    plt.title('Entropy function of Epsilon')
    plt.xlabel('Epsilon')
    plt.ylabel('Entropy')

    plt.show(block=False)

    rep = input("\nDo you want to save your results ? (Y/n): ")
    if rep.lower() == 'y':
      while True:
        name_plot = input("Please, give a name to your plot: ")
        if not os.path.exists(f'{name_plot}.png'):
            break
        else:
            rep2 = input(f"The file '{name_plot}.png' already exists. Do you want to replace it? (Y/n): ")
            if rep2.lower() == 'y':
                break

      plt.savefig(f'{name_plot}.png')
      print("Epsilon plot has been successfully saved")

      while True:
        name_file = input("Please, give a name to your backup file: ")
        if not os.path.exists(f'{name_file}'):
            a=0
            break
        else:
            rep3 = input(f"The file '{name_file}' already exists. Do you want to write Espilon max inside? (Y/n): ")
            if rep3.lower() == 'y':
                a=1
                break
            else:
                rep4 = input(f"Do you want to replace '{name_file}'? (Y/n): ")
                if rep4.lower() == 'y':
                    a=2
                    break

        if a == 0 or a == 2:
            with open(name_file, 'w') as fichier:
                fichier.write('\n-----------Optimal Epsilon with Entropy function-----------' + '\n' + str(round(EpsiOptiH, 3)))
        if a == 1:
            with open(name_file, 'a') as fichier:
                fichier.write('\n-----------Optimal Epsilon with Entropy function-----------' + '\n' + str(round(EpsiOptiH, 3)))

        print(f"Optimal Epsilon with Entropy function has been successfully saved in '{name_file}'")

    return EpsiOptiH

def epsi_utility(y, step):
  y = np.array(y)
  epsi = 0
  D = cdist(y, y, 'euclidean')
  nbr_epsi = int(math.ceil(np.max(D))/step)

  Epsi = np.zeros(nbr_epsi)
  trP = np.zeros(nbr_epsi)
  hr = np.zeros(nbr_epsi)
  hc = np.zeros(nbr_epsi)
  u = np.zeros(nbr_epsi)

  for e in range(nbr_epsi):
    epsi = epsi + step
    R = np.array(D<epsi)
    R=R.astype(int)

    R=np.tril(R)

    #------------------------------------------------------------------------------
    #Rewriting grammar
    Serie=np.zeros((R.shape[1]))

    for i in range(R.shape[1]):
      Serie[i]=i+1

    for i in range(R.shape[0]):
      Indx = np.where(R[R.shape[0]-1-i, :]!=0)
      Valmin = int(Serie[np.min(Indx[0])])
      for j in Indx[0]:
          if Valmin < Serie[j]:
            Serie[Serie==Serie[j]] = Valmin

    #-----------------------------------------------------------------------------
    #Writing zeros
    newSerie = np.array(Serie)
    for i in range(Serie.shape[0]):
      if i != 0 and i != Serie.shape[0]-1:
        if Serie[i-1]!=Serie[i] and Serie[i]!=Serie[i+1]:
          newSerie[i]=0
      if i==0:
        if Serie[i]!=Serie[i+1] and Serie[i]!=Serie[Serie.shape[0]-1]:
          newSerie[i]=0
      if i==Serie.shape[0]-1:
        if Serie[i]!=Serie[i-1] and Serie[i]!=Serie[0]:
          newSerie[i]=0

    #-----------------------------------------------------------------------------
    #Writing continuous number's sequence
    sort = 0
    Ser = np.sort(newSerie)
    S = np.unique(Ser)
    for i in S:
      newSerie = np.where(newSerie == i, sort, newSerie)
      sort = sort+1


    # Utility
    Serie = newSerie
    n = int(np.max(Serie)+1)
    if n>2:
      r=0
      q=0

      for i in range(len(Serie)-1):
        if Serie[i] == 0 and Serie[i+1]!=0:
          r = r+1
        elif Serie[i] != 0 and Serie[i+1] == 0:
          q = q+1

      r=r/(len(Serie)-1)
      q=q/(len(Serie)-1)

      trP[e] = 1+(n-1)*(1-q-r)

      numc = 0
      numr = 0
      pi0 = np.zeros(n)
      p0i = np.zeros(n)
      Serie = Serie.astype(int)

      for i in Serie:
        if i == 0 and numc != 0:
          pi0[incc-1] += 1
        elif i != 0:
          incc = i
        if i != 0 and numr == 0:
          incr = i
          p0i[incr-1] += 1
        numr = i
        numc = i
      shc = 0
      shr = 0
      for i in range(len(pi0)):
        if pi0[i] != 0:
          pi0_prime = pi0[i]/np.sum(pi0)
          shc = shc + pi0_prime*math.log(pi0_prime)
        if p0i[i] != 0:
          p0i_prime = p0i[i]/np.sum(p0i)
          shr = shr + p0i_prime*math.log(p0i_prime)

      hc[e] = -shc*1/math.log(n-1)
      hr[e] = -shr*1/math.log(n-1)
    else:
      hc[e] = 0
      hr[e] = 0

    u[e] = 1/(n+2) * (trP[e] + hr[e] + hc[e])
    Epsi[e] = epsi

  Umax = np.max(u)
  IndxUmax = np.argmax(u)
  EpsiOptiU = Epsi[IndxUmax]

  print('\n----------Utility Optimal Epsilon-------------')
  print('Epsilon with Utility Function =',round(EpsiOptiU, 3))
  f=plt.figure()
  plt.plot(Epsi, u)

  plt.title('Utility function of Epsilon')
  plt.xlabel('Epsilon')
  plt.ylabel('Utility function')

  plt.show(block=False)

  rep = input("\nDo you want to save your results ? (Y/n): ")
  if rep.lower() == 'y':
      while True:
          name_plot = input("Please, give a name to your plot: ")
          if not os.path.exists(f'{name_plot}.png'):
              break
          else:
              rep2 = input(f"The file '{name_plot}.png' already exists. Do you want to replace it? (Y/n): ")
              if rep2.lower() == 'y':
                  break

      plt.savefig(f'{name_plot}.png')
      print("Epsilon plot has been successfully saved")

      while True:
          name_file = input("Please, give a name to your backup file: ")
          if not os.path.exists(f'{name_file}.txt'):
              a=0
              break
          else:
              rep3 = input(f"The file '{name_file}' already exists. Do you want to write Espilon max inside? (Y/n): ")
              if rep3.lower() == 'y':
                  a=1
                  break
              else:
                  rep4 = input(f"Do you want to replace '{name_file}'? (Y/n): ")
                  if rep4.lower() == 'y':
                      a=2
                      break

      if a == 0 or a == 2:
          with open(name_file, 'w') as fichier:
              fichier.write('\n-----------Optimal Epsilon with Utility function-----------' + '\n' + str(round(EpsiOptiU, 3)))
      if a == 1:
          with open(name_file, 'a') as fichier:
              fichier.write('\n-----------Optimal Epsilon with Utility function-----------' + '\n' + str(round(EpsiOptiU, 3)))

      print(f"Optimal Epsilon with Utility function has been successfully saved in '{name_file}'")


  return EpsiOptiU

def test_epsi(y):
  y = np.array(y)
  test=0
  while test==0:

    #----------------------Rec_mat:-----------------------
    epsilon = input("Enter epsilon value : e = ")
    epsi=float(epsilon)
    D = cdist(y, y, 'euclidean')
    R = np.array(D<epsi)
    R=R.astype(int)
    print('\n-----------Recurrence matrix-----------')
    print(R)

    #----------------------Rec_plot:-----------------------
    x, y1 = np.where(R == 1)
    fig=plt.figure()
    plt.scatter(x, y1, c='black', marker='o')
    plt.show(block=False)


    #----------------------Symbolic_serie:----------------------
    #Rewriting grammar
    Serie=np.zeros((R.shape[1]))

    for i in range(R.shape[1]):
      Serie[i]=i+1

    for i in range(R.shape[0]):
      Indx = np.where(R[R.shape[0]-1-i, :]!=0)
      Valmin = int(Serie[np.min(Indx[0])])
      for j in Indx[0]:
          if Valmin < Serie[j]:
            Serie[Serie==Serie[j]] = Valmin

    #Writing zeros
    newSerie = np.array(Serie)
    for i in range(Serie.shape[0]):
      if i != 0 and i != Serie.shape[0]-1:
        if Serie[i-1]!=Serie[i] and Serie[i]!=Serie[i+1]:
          newSerie[i]=0
      if i==0:
        if Serie[i]!=Serie[i+1] and Serie[i]!=Serie[Serie.shape[0]-1]:
          newSerie[i]=0
      if i==Serie.shape[0]-1:
        if Serie[i]!=Serie[i-1] and Serie[i]!=Serie[0]:
          newSerie[i]=0

    #Writing continuous number's sequence
    sort = 0
    Ser = np.sort(newSerie)
    S = np.unique(Ser)
    for i in S:
      newSerie = np.where(newSerie == i, sort, newSerie)
      sort = sort+1

    print('\n-----------Symbolic serie-----------')
    print(newSerie)

    #----------------------Colored_symbolic_serie:----------------------
    position = 0
    serie = newSerie
    palette = ['red', 'blue', 'yellow', 'green', 'purple', 'orange', 'black', 'pink', 'brown', 'gray', 'turquoise', 'indigo', 'beige', 'olive', 'cyan', 'magenta', 'gold', 'silver', 'coral', 'lavender', 'chartreuse', 'orangered', 'aquamarine', 'skyblue', 'pumpkin', 'emerald']
    if len(palette) > np.max(serie) :
      fig, ax = plt.subplots()
      for couleur in serie:
          ax.barh(0, 1, color=palette[int(couleur)], height=0.2, left=position)
          position += 1
      plt.show(block=False)


      #----------------------Colored_trajectory:----------------------
      ax.set_ylim(-0.5, 0.5)
      ax.axis('off')
      figure = plt.figure()
      if y.shape[1] == 3 :
        ax = figure.add_subplot(111, projection='3d')
        for i in range(serie.shape[0]):
          ax.scatter(y[i, 0],y[i,1],y[i,2], color=palette[int(serie[i])], marker='o')
      elif y.shape[1] == 2:
        for i in range(serie.shape[0]):
          plt.scatter(y[i,0], y[i,1], color=palette[int(serie[i])], marker = 'o')
      elif y.shape[1] == 1:
        for i in range(serie.shape[0]):
          plt.scatter(y[i], 0, color=palette[int(serie[i])], marker='o')
      plt.show(block=False)


    else :
      print("Your data is too complexe to color a trajectory")


    #----------------------Complexity:----------------------

    # Alphabet size
    C_alphabet_size = np.max(serie)+1

    print('\n------------- Complexity with the alphabet size method -------------\n')
    print('Complexity alphabet size = ' + str(C_alphabet_size))

    # Number of words
    a = 0
    b = 0
    W_nw = []

    for i in range(len(serie)-1):
        w = ''
        if serie[i] != serie[i+1]:
            for j in range(a, i, 1):
                w = w + str(serie[j])
            W_nw.append(w)
            b = b + 1
            a = i + 1
    unique = set(W_nw)
    C_nbr_words = len(unique)
    print('\n------------- Complexity with the number of words method -------------\n')
    print('Complexity number of words = ' + str(C_nbr_words))

    # Lempel-Ziv

    def pattern_in_serie(w, s):
      w_str = ''
      s_str = ''
      for a in w:
        w_str=w_str+str(a)
      for b in s:
        s_str = s_str+str(b)
      return s_str in w_str

    C_LZ = 0
    i = 0
    W_LZ = []
    W_LZ.append(serie[i])
    i = 1
    while i < len(serie):
        j = i
        Bool = pattern_in_serie(W_LZ[:j], str(serie[j]))
        if Bool == False:
            W_LZ.append(str(serie[i]))
            i = i + 1
        else:
            while Bool == True:
                j = j + 1
                if j >= len(serie):
                    break
                Bool = pattern_in_serie(W_LZ[:j], serie[i:j + 1])
            W_LZ.append(''.join(map(str, serie[i:j + 1])))
            i = j + 1

    C_LZ = len(W_LZ)

    print('\n------------- Complexity with the Lempel-Ziv method -------------\n')
    print('Complexity Lempel-Ziv = ' + str(C_LZ))
    print('\n')


    ans = input("\nAre these results satisfying ? (Y/n): ")
    if ans.lower() == 'y':
      test=1

  rep = input("Do you want to save your results ? (Y/n): ")
  if rep.lower() == 'y':
    while True:
      name_file = input("Please, give a name to your backup files: ")
      if not os.path.exists(f'{name_file}'):
          a=0
          break
      else:
        rep4 = input(f"{name_file} already exists. Do you want to replace it ? (Y/n): ")
        if rep4.lower() == 'y':
          with open(name_file, 'w') as fichier:
            fichier.write('\n-----------Epsilon-----------\n')
            fichier.write('epsilon = '+ epsilon + '\n\n')
            fichier.write('\n-----------Recurrence matrix-----------\n')
            np.savetxt(fichier, R, fmt='%d', delimiter='\t', newline='\n', header='', footer='', comments='')
            fichier.write('\n\n-----------Symbolic serie-----------\n')
            np.savetxt(fichier, newSerie, fmt='%d', delimiter='\t', newline='\n', header='', footer='', comments='')
          plt.figure(1).savefig(f"{name_file}_rec_plot.png")
          plt.figure(2).savefig(f"{name_file}_colored_serie.png")
          plt.figure(3).savefig(f"{name_file}_colored_trajectory.png")

    with open(name_file, 'w') as fichier:
      fichier.write('\n-----------Epsilon-----------\n')
      fichier.write('epsilon = '+ epsilon + '\n\n')
      fichier.write('\n-----------Recurrence matrix-----------\n')
      np.savetxt(fichier, R, fmt='%d', delimiter='\t', newline='\n', header='', footer='', comments='')
      fichier.write('\n\n-----------Symbolic serie-----------\n')
      np.savetxt(fichier, newSerie, fmt='%d', delimiter='\t', newline='\n', header='', footer='', comments='')
    plt.figure(1).savefig(f"{name_file}_rec_plot.png")
    plt.figure(2).savefig(f"{name_file}_colored_serie.png")
    plt.figure(3).savefig(f"{name_file}_colored_trajectory.png")

    print("Results successfully saved !")