# -*- coding: utf-8 -*-
"""opti_epsi.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1L0gckCYfD-DhzbvIlU5qZfF1LF_XLT3v
"""

import numpy as np
import math
import matplotlib.pyplot as plt
from scipy.spatial.distance import cdist
import io
import os
from RASCoPy import symbolic_series
import random

def epsi_entropy(y, step, visu=None, back_file=None):
  y = np.array(y)
  epsi = 0
  D = cdist(y, y, 'euclidean')
  nbr_epsi = int(math.ceil(np.max(D))/step)

  Entropy = np.zeros(nbr_epsi)
  Epsi = np.zeros(nbr_epsi)

  for e in range(nbr_epsi):
    epsi = epsi + step
    R = np.array(D<epsi)
    R=R.astype(int)

    #R=np.tril(R)

    #------------------------------------------------------------------------------
    #Rewriting grammar
    Serie=np.zeros((R.shape[1]))

    for i in range(R.shape[1]):
      Serie[i]=i+1

    for i in range(R.shape[0]):
      Indx = np.where(R[R.shape[0]-1-i, :]!=0)
      Valmin = 1000000000

      for k in Indx[0]:
        if Serie[k] <= Valmin:
          Valmin = Serie[k]

      for j in Indx[0]:
          if Valmin <= Serie[j]:
            Serie[Serie==Serie[j]] = Valmin

    #-----------------------------------------------------------------------------
    #Writing zeros
    newSerie = np.array(Serie)
    for i in range(Serie.shape[0]):
      if i != 0 and i != Serie.shape[0]-1:
        if Serie[i-1]!=Serie[i] and Serie[i]!=Serie[i+1]:
          newSerie[i]=0
      if i==0:
        if (Serie[i]!=Serie[i+1] and Serie[i]!=Serie[Serie.shape[0]-1]) and np.count_nonzero(Serie == Serie[i])==1:
          newSerie[i]=0
      if i==Serie.shape[0]-1:
        if (Serie[i]!=Serie[i-1] and Serie[i]!=Serie[0]) and np.count_nonzero(Serie == Serie[i])==1:
          newSerie[i]=0
    for i in newSerie:
      if np.count_nonzero(newSerie == i) <= 2:
          newSerie[np.where(newSerie == i)] = 0

    #-----------------------------------------------------------------------------
    #Writing continuous number's sequence
    sort = 1
    Ser = np.sort(newSerie)
    S = np.unique(Ser)
    for i in S:
      if i != 0:
        newSerie = np.where(newSerie == i, sort, newSerie)
        sort = sort+1

    #Entropy
    Serie=newSerie
    Serie = Serie.astype(int)
    p = np.array(np.unique(Serie).shape[0])
    H=0
    occurrences = np.bincount(Serie)
    for valeur, nb_occurrences in enumerate(occurrences):
        if nb_occurrences > 0:
            pi = nb_occurrences/Serie.shape[0]
            H=H+pi*np.log2(pi)

    Hneg = -H
    Entropy[e]= Hneg
    Epsi[e] = epsi

  # Results epsilon
  Hmax = np.max(Entropy)
  IndxHmax = np.argmax(Entropy)
  EpsiOptiH = Epsi[IndxHmax]

  if visu is not None:
    print('\n---------Entropy Optimal Epsilon----------')
    print('Epsilon with maximum Entropy =', round(EpsiOptiH, 3))

    fig = plt.figure()
    plt.plot(Epsi, Entropy)
    plt.title('Entropy function of Epsilon')
    plt.xlabel('Epsilon')
    plt.ylabel('Entropy')

    plt.show(block=False)
    while(True):
      rep = input("\nDo you want to save your results ? (Y/n): ")
      if rep.lower() == 'y':
        while True:
          name_plot = input("Please, give a name to your plot: ")
          if not os.path.exists(f'{name_plot}.png'):
              break
          else:
              rep2 = input(f"The file '{name_plot}.png' already exists. Do you want to replace it? (Y/n): ")
              if rep2.lower() == 'y':
                  break

        plt.savefig(f'{name_plot}.png')
        print("Epsilon plot has been successfully saved")

        if back_file is not None:
          with open(back_file, 'a') as fichier:
            fichier.write('\n-----------Optimal Epsilon with Entropy function-----------' + '\n' + str(round(EpsiOptiH, 3)))
          print(f"Optimal Epsilon with Entropy function has been successfully saved in '{back_file}'")
        else :
          while True:
            name_file = input("Please, give a name to your backup file: ")
            if not os.path.exists(f'{name_file}'):
              with open(name_file, 'w') as fichier:
                fichier.write('\n-----------Optimal Epsilon with Entropy function-----------' + '\n' + str(round(EpsiOptiH, 3)))
              print(f"Optimal Epsilon with Entropy function has been successfully saved in '{name_file}'")
              break
            else:
                rep2 = input(f"The file '{name_file}' already exists. Do you want to replace it ? (Y/n): ")
            if rep2.lower() == 'y':
              with open(name_file, 'w') as fichier:
                fichier.write('\n-----------Optimal Epsilon with Entropy function-----------' + '\n' + str(round(EpsiOptiH, 3)))
              print(f"Optimal Epsilon with Entropy function has been successfully saved in '{name_file}'")
              break
            else:
              rep3 = input(f"Do you want to add your result in it ? (Y/n): ")
            if rep3.lower() == 'y':
              with open(name_file, 'a') as fichier:
                fichier.write('\n-----------Optimal Epsilon with Entropy function-----------' + '\n' + str(round(EpsiOptiH, 3)))
              print(f"Optimal Epsilon with Entropy function has been successfully saved in '{name_file}'")
              break
        break
      elif rep.lower() == 'n':
        break

  return EpsiOptiH

def epsi_utility(y, step, visu=None, back_file=None):
  y = np.array(y)
  epsi = 0
  D = cdist(y, y, 'euclidean')
  nbr_epsi = int(math.ceil(np.max(D))/step)

  Epsi = np.zeros(nbr_epsi)
  trP = np.zeros(nbr_epsi)
  hr = np.zeros(nbr_epsi)
  hc = np.zeros(nbr_epsi)
  u = np.zeros(nbr_epsi)

  for e in range(nbr_epsi):
    epsi = epsi + step
    R = np.array(D<epsi)
    R=R.astype(int)

    #R=np.tril(R)

    #------------------------------------------------------------------------------
    #Rewriting grammar
    Serie=np.zeros((R.shape[1]))

    for i in range(R.shape[1]):
      Serie[i]=i+1

    for i in range(R.shape[0]):
      Indx = np.where(R[R.shape[0]-1-i, :]!=0)
      Valmin = 1000000000

      for k in Indx[0]:
        if Serie[k] <= Valmin:
          Valmin = Serie[k]

      for j in Indx[0]:
          if Valmin <= Serie[j]:
            Serie[Serie==Serie[j]] = Valmin

    #-----------------------------------------------------------------------------
    #Writing zeros
    newSerie = np.array(Serie)
    for i in range(Serie.shape[0]):
      if i != 0 and i != Serie.shape[0]-1:
        if Serie[i-1]!=Serie[i] and Serie[i]!=Serie[i+1]:
          newSerie[i]=0
      if i==0:
        if (Serie[i]!=Serie[i+1] and Serie[i]!=Serie[Serie.shape[0]-1]) and np.count_nonzero(Serie == Serie[i])==1:
          newSerie[i]=0
      if i==Serie.shape[0]-1:
        if (Serie[i]!=Serie[i-1] and Serie[i]!=Serie[0]) and np.count_nonzero(Serie == Serie[i])==1:
          newSerie[i]=0
    for i in newSerie:
      if np.count_nonzero(newSerie == i) <= 2:
          newSerie[np.where(newSerie == i)] = 0
    #-----------------------------------------------------------------------------
    #Writing continuous number's sequence
    sort = 1
    Ser = np.sort(newSerie)
    S = np.unique(Ser)
    for i in S:
      if i != 0:
        newSerie = np.where(newSerie == i, sort, newSerie)
        sort = sort+1

    uniqSerie = np.unique(newSerie)
    if len(uniqSerie)>2:
      # Utility
      Serie = newSerie
      n = int(np.max(Serie)+1)
      if n>2:
        r=0
        q=0

        for i in range(len(Serie)-1):
          if Serie[i] == 0 and Serie[i+1]!=0:
            r = r+1
          elif Serie[i] != 0 and Serie[i+1] == 0:
            q = q+1

        r=r/(len(Serie)-1)
        q=q/(len(Serie)-1)

        trP[e] = 1+(n-1)*(1-q-r)

        numc = 0
        numr = 0
        pi0 = np.zeros(n)
        p0i = np.zeros(n)
        Serie = Serie.astype(int)

        for i in Serie:
          if i == 0 and numc != 0:
            pi0[incc-1] += 1
          elif i != 0:
            incc = i
          if i != 0 and numr == 0:
            incr = i
            p0i[incr-1] += 1
          numr = i
          numc = i
        shc = 0
        shr = 0
        for i in range(len(pi0)):
          if pi0[i] != 0:
            pi0_prime = pi0[i]/np.sum(pi0)
            shc = shc + pi0_prime*math.log(pi0_prime)
          if p0i[i] != 0:
            p0i_prime = p0i[i]/np.sum(p0i)
            shr = shr + p0i_prime*math.log(p0i_prime)

        hc[e] = -shc*1/math.log(n-1)
        hr[e] = -shr*1/math.log(n-1)
      else:
        hc[e] = 0
        hr[e] = 0

      u[e] = 1/(n+2) * (trP[e] + hr[e] + hc[e])
      Epsi[e] = epsi

  Umax = np.max(u)
  IndxUmax = np.argmax(u)
  EpsiOptiU = Epsi[IndxUmax]

  if visu is not None:
    print('\n----------Utility Optimal Epsilon-------------')
    print('Epsilon with Utility Function =',round(EpsiOptiU, 3))
    f=plt.figure()
    plt.plot(Epsi, u)

    plt.title('Utility function of Epsilon')
    plt.xlabel('Epsilon')
    plt.ylabel('Utility function')

    plt.show(block=False)
    while(True):
      rep = input("\nDo you want to save your result ? (Y/n): ")
      if rep.lower() == 'y':
        while True:
          name_plot = input("Please, give a name to your plot: ")
          if not os.path.exists(f'{name_plot}.png'):
              break
          else:
              rep2 = input(f"The file '{name_plot}.png' already exists. Do you want to replace it? (Y/n): ")
              if rep2.lower() == 'y':
                  break

        plt.savefig(f'{name_plot}.png')
        print("Epsilon plot has been successfully saved")

        if back_file is not None:
          with open(back_file, 'a') as fichier:
              fichier.write('\n-----------Optimal Epsilon with Utility function-----------' + '\n' + str(round(EpsiOptiU, 3)))
          print(f"Optimal Epsilon with Utility function has been successfully saved in '{back_file}'")
        else :
          while True:
            name_file = input("Please, give a name to your backup file: ")
            if not os.path.exists(f'{name_file}'):
              with open(name_file, 'w') as fichier:
                fichier.write('\n-----------Optimal Epsilon with Utility function-----------' + '\n' + str(round(EpsiOptiU, 3)))
              print(f"Optimal Epsilon with Utility function has been successfully saved in '{name_file}'")
              break
            else:
                rep2 = input(f"The file '{name_file}' already exists. Do you want to replace it ? (Y/n): ")
            if rep2.lower() == 'y':
              with open(name_file, 'w') as fichier:
                fichier.write('\n-----------Optimal Epsilon with Utility function-----------' + '\n' + str(round(EpsiOptiU, 3)))
              print(f"Optimal Epsilon with Utility function has been successfully saved in '{name_file}'")
              break
            else:
              rep3 = input(f"Do you want to add your serie in it ? (Y/n): ")
            if rep3.lower() == 'y':
              with open(name_file, 'a') as fichier:
                fichier.write('\n-----------Optimal Epsilon with Utility function-----------' + '\n' + str(round(EpsiOptiU, 3)))
              print(f"Optimal Epsilon with Utility function has been successfully saved in '{name_file}'")
              break
        break
      elif rep.lower() == 'n':
        break


  return EpsiOptiU

def test_epsi(y, back_file=None):
  y = np.array(y)
  test=0
  while test==0:

    #----------------------Rec_mat:-----------------------
    epsilon = input("Enter epsilon value : e = ")
    epsi=float(epsilon)
    D = cdist(y, y, 'euclidean')
    R = np.array(D<epsi)
    R=R.astype(int)
    print('\n-----------Recurrence matrix-----------')
    print(R)

    #----------------------Rec_plot:-----------------------
    x, y1 = np.where(R == 1)
    fig=plt.figure()
    plt.scatter(x, y1, c='black', marker='o')
    plt.show(block=False)


    #----------------------Symbolic_serie:----------------------
    #Rewriting grammar
    Serie=np.zeros((R.shape[1]))

    for i in range(R.shape[1]):
      Serie[i]=i+1

    for i in range(R.shape[0]):
      Indx = np.where(R[R.shape[0]-1-i, :]!=0)
      Valmin = int(Serie[np.min(Indx[0])])
      for j in Indx[0]:
          if Valmin < Serie[j]:
            Serie[Serie==Serie[j]] = Valmin

    #Writing zeros
    newSerie = np.array(Serie)
    for i in range(Serie.shape[0]):
      if i != 0 and i != Serie.shape[0]-1:
        if Serie[i-1]!=Serie[i] and Serie[i]!=Serie[i+1]:
          newSerie[i]=0
      if i==0:
        if Serie[i]!=Serie[i+1] and Serie[i]!=Serie[Serie.shape[0]-1]:
          newSerie[i]=0
      if i==Serie.shape[0]-1:
        if Serie[i]!=Serie[i-1] and Serie[i]!=Serie[0]:
          newSerie[i]=0

    #Writing continuous number's sequence
    sort = 0
    Ser = np.sort(newSerie)
    S = np.unique(Ser)
    for i in S:
      newSerie = np.where(newSerie == i, sort, newSerie)
      sort = sort+1

    print('\n-----------Symbolic serie-----------')
    print(newSerie)

    #----------------------Colored_symbolic_serie:----------------------
    position = 0
    serie = newSerie
    palette = ['red', 'blue', 'yellow', 'green', 'purple', 'orange', 'black', 'pink', 'brown', 'gray', 'turquoise', 'indigo', 'beige', 'olive', 'cyan', 'magenta', 'gold', 'silver', 'coral', 'lavender', 'chartreuse', 'orangered', 'aquamarine', 'skyblue', 'pumpkin', 'emerald']
    if len(palette) > np.max(serie) :
      fig, ax = plt.subplots()
      for couleur in serie:
          ax.barh(0, 1, color=palette[int(couleur)], height=0.2, left=position)
          position += 1
      plt.show(block=False)


      #----------------------Colored_trajectory:----------------------
      ax.set_ylim(-0.5, 0.5)
      ax.axis('off')
      figure = plt.figure()
      if y.shape[1] == 3 :
        ax = figure.add_subplot(111, projection='3d')
        for i in range(serie.shape[0]):
          ax.scatter(y[i, 0],y[i,1],y[i,2], color=palette[int(serie[i])], marker='o')
      elif y.shape[1] == 2:
        for i in range(serie.shape[0]):
          plt.scatter(y[i,0], y[i,1], color=palette[int(serie[i])], marker = 'o')
      elif y.shape[1] == 1:
        for i in range(serie.shape[0]):
          plt.scatter(y[i], 0, color=palette[int(serie[i])], marker='o')
      plt.show(block=False)


    else :
      print("Your data is too complexe to color a trajectory")


    #----------------------Complexity:----------------------

    # Alphabet size
    C_alphabet_size = np.max(serie)+1

    print('\n------------- Complexity with the alphabet size method -------------\n')
    print('Complexity alphabet size = ' + str(C_alphabet_size))

    # Number of words
    a = 0
    b = 0
    W_nw = []

    for i in range(len(serie)-1):
        w = ''
        if serie[i] != serie[i+1]:
            for j in range(a, i, 1):
                w = w + str(serie[j])
            W_nw.append(w)
            b = b + 1
            a = i + 1
    unique = set(W_nw)
    C_nbr_words = len(unique)
    print('\n------------- Complexity with the number of words method -------------\n')
    print('Complexity number of words = ' + str(C_nbr_words))

    # Lempel-Ziv

    def pattern_in_serie(w, s):
      w_str = ''
      s_str = ''
      for a in w:
        w_str=w_str+str(a)
      for b in s:
        s_str = s_str+str(b)
      return s_str in w_str

    C_LZ = 0
    i = 0
    W_LZ = []
    W_LZ.append(serie[i])
    i = 1
    while i < len(serie):
        j = i
        Bool = pattern_in_serie(W_LZ[:j], str(serie[j]))
        if Bool == False:
            W_LZ.append(str(serie[i]))
            i = i + 1
        else:
            while Bool == True:
                j = j + 1
                if j >= len(serie):
                    break
                Bool = pattern_in_serie(W_LZ[:j], serie[i:j + 1])
            W_LZ.append(''.join(map(str, serie[i:j + 1])))
            i = j + 1

    C_LZ = len(W_LZ)

    print('\n------------- Complexity with the Lempel-Ziv method -------------\n')
    print('Complexity Lempel-Ziv = ' + str(C_LZ))
    print('\n')


    ans = input("\nAre these results satisfying ? (Y/n): ")
    if ans.lower() == 'y':
      test=1

  if back_file is not None:
    rep = input("Do you want to save your results ? (Y/n): ")
    if rep.lower() == 'y':
      with open(back_file, 'a') as fichier:
        fichier.write('\n\n-----------Epsilon-----------\n')
        fichier.write('epsilon = '+ epsilon + '\n\n')
        fichier.write('\n-----------Recurrence matrix-----------\n')
        np.savetxt(fichier, R, fmt='%d', delimiter='\t', newline='\n', header='', footer='', comments='')
        fichier.write('\n\n-----------Symbolic serie-----------\n')
        np.savetxt(fichier, newSerie, fmt='%d', delimiter='\t', newline='\n', header='', footer='', comments='')
      plt.figure(1).savefig(f"{back_file}_rec_plot.png")
      plt.figure(2).savefig(f"{back_file}_colored_serie.png")
      plt.figure(3).savefig(f"{back_file}_colored_trajectory.png")
      print("Results successfully saved !")
  else :
    rep = input("Do you want to save your results ? (Y/n): ")
    if rep.lower() == 'y':
      while True:
        name_file = input("Please, give a name to your backup file: ")
        if not os.path.exists(f'{name_file}'):
          with open(name_file, 'w') as fichier:
            fichier.write('\n\n-----------Epsilon-----------\n')
            fichier.write('epsilon = '+ epsilon + '\n\n')
            fichier.write('\n-----------Recurrence matrix-----------\n')
            np.savetxt(fichier, R, fmt='%d', delimiter='\t', newline='\n', header='', footer='', comments='')
            fichier.write('\n\n-----------Symbolic serie-----------\n')
            np.savetxt(fichier, newSerie, fmt='%d', delimiter='\t', newline='\n', header='', footer='', comments='')
          plt.figure(1).savefig(f"{name_file}_rec_plot.png")
          plt.figure(2).savefig(f"{name_file}_colored_serie.png")
          plt.figure(3).savefig(f"{name_file}_colored_trajectory.png")
          print("Results successfully saved !")
          break
        else:
            rep2 = input(f"The file '{name_file}' already exists. Do you want to replace it ? (Y/n): ")
        if rep2.lower() == 'y':
          with open(name_file, 'w') as fichier:
            fichier.write('\n\n-----------Epsilon-----------\n')
            fichier.write('epsilon = '+ epsilon + '\n\n')
            fichier.write('\n-----------Recurrence matrix-----------\n')
            np.savetxt(fichier, R, fmt='%d', delimiter='\t', newline='\n', header='', footer='', comments='')
            fichier.write('\n\n-----------Symbolic serie-----------\n')
            np.savetxt(fichier, newSerie, fmt='%d', delimiter='\t', newline='\n', header='', footer='', comments='')
          plt.figure(1).savefig(f"{name_file}_rec_plot.png")
          plt.figure(2).savefig(f"{name_file}_colored_serie.png")
          plt.figure(3).savefig(f"{name_file}_colored_trajectory.png")
          print("Results successfully saved !")
          break
        else:
          rep3 = input(f"Do you want to add your results in it ? (Y/n): ")
        if rep3.lower() == 'y':
          with open(name_file, 'a') as fichier:
            fichier.write('\n\n-----------Epsilon-----------\n')
            fichier.write('epsilon = '+ epsilon + '\n\n')
            fichier.write('\n-----------Recurrence matrix-----------\n')
            np.savetxt(fichier, R, fmt='%d', delimiter='\t', newline='\n', header='', footer='', comments='')
            fichier.write('\n\n-----------Symbolic serie-----------\n')
            np.savetxt(fichier, newSerie, fmt='%d', delimiter='\t', newline='\n', header='', footer='', comments='')
          plt.figure(1).savefig(f"{name_file}_rec_plot.png")
          plt.figure(2).savefig(f"{name_file}_colored_serie.png")
          plt.figure(3).savefig(f"{name_file}_colored_trajectory.png")
          print("Results successfully saved !")
          break

def opti_epsi_phi(y, length, step, visu=None, back_file=None):
    epsi = 0
    D = cdist(y, y, 'euclidean')
    nbr_epsi = int(math.ceil(np.max(D))/step)

    Epsi = []
    trp = []
    detp = []
    tr_des = []
    det_des = []
    Sum_Pij = []
    
    #------------------------------------------------------------------------PHI FUNCTION-----------------------------------------------------------
    for e in range(nbr_epsi):
        sumpij=0
        epsi = epsi + step
        R = np.array(D<epsi)
        R=R.astype(int)

        serie = symbolic_series.symbolic_serie(R)
        serie=serie.astype(int)
        if len(np.unique(serie)) == 1 and np.unique(serie) == 1 :
            break
        else :
            if len(np.unique(serie))>2:
                Epsi.append(epsi)
                f = np.zeros((np.max(serie)+1, np.max(serie)+1))
                r=0
                q=0
                for i in range(len(serie)-1):
                    if serie[i] == 0 and serie[i+1]!=0:
                        r = r+1
                    elif serie[i] != 0 and serie[i+1] == 0:
                        q = q+1
                    f[serie[i], serie[i+1]] = f[serie[i], serie[i+1]] + 1
                s = np.sum(f, axis=0)
                n = f.shape[0]
                P = np.zeros((n, n))
                for i in range(n):
                    for j in range(n):
                        if s[j] != 0:
                            P[i,j] = f[i,j]/s[j]
                        else:
                            P[i,j]=0
                for i in range(1,n):
                    for j in range(1,n):
                        if i!=j and i!=0 and j!= 0:
                            sumpij = sumpij+P[i,j]

                r=r/(len(serie))
                q=q/(len(serie))

                mat_des = np.zeros((n, n))
                for i in range(n):
                    mat_des[0, i] = q if i != 0 else 1 - (n - 1) * q
                    mat_des[i, 0] = r if i != 0 else 1 - (n - 1) * q
                    mat_des[i, i] = 1 - r if i != 0 else 1 - (n - 1) * q

                trp.append(np.trace(P)) 
                detp.append(np.linalg.det(P))
                tr_des.append(np.trace(mat_des))
                det_des.append(np.linalg.det(mat_des))
                Sum_Pij.append(sumpij)

    err_det = [abs(alpha - beta) for alpha, beta in zip(det_des, detp)]
    err_tr = [abs(alpha - beta) for alpha, beta in zip(tr_des, trp)]
    #--------------------------------------------------------------------------------Loop-----------------------------------------------------------------------------------------------
    w1_best=None
    w2_best=None
    lam_best=None
    best_loss = float('inf')
    counter=0

    maxpeak=0
    minpeak=0
    for i in range(len(y[:,0])):
        if i-10 >= 0 and i+10 < len(y[:,0]):
            if np.all(y[i,0] > y[i-10:i,0]) and np.all(y[i,0] > y[i+1:i+11,0]):
                maxpeak = maxpeak+1
            if np.all(y[i,0] < y[i-10:i, 0]) and np.all(y[i,0] < y[i+1:i+11,0]):
                minpeak=minpeak+1
        elif i-10 >= 0 and i+10 >= len(y[:,0]):
            if np.all(y[i,0] > y[i-10:i,0]) and np.all(y[i,0] > y[i+1:len(y[:,0])-1,0]):
                maxpeak = maxpeak+1
            if np.all(y[i,0] < y[i-10:i, 0]) and np.all(y[i,0] < y[i+1:len(y[:,0])-1,0]):
                minpeak=minpeak+1
        elif i-10 < 0 and i+10 < len(y[:,0]):
            if np.all(y[i,0] > y[0:i,0]) and np.all(y[i,0] > y[i+1:i+11,0]):
                maxpeak = maxpeak+1
            if np.all(y[i,0] < y[0:i, 0]) and np.all(y[i,0] < y[i+1:i+11,0]):
                minpeak=minpeak+1

    iterations=5000
    alpha_des = 3
    word_des = 2*(maxpeak+minpeak)
    Lz_des_min, Lz_des_max = find_CLZ(length)
    if y.shape[1]==2:
        Lz_des = Lz_des_min
    elif y.shape[1]==3:
        Lz_des = (Lz_des_min+Lz_des_max)/2
    tol = 3

    while(counter<iterations):
        
        counter=counter+1
        #---------------------------------------------------------------------Initialisation----------------------------------------------------------------------------------
        w1 = round(random.uniform(0.1, 1), 1)
        w2 = round(random.uniform(0.1, 1), 1)
        lam = round(random.uniform(0.1, 1), 1)
        
        phi = [w1*alpha + w2*beta + lam*gamma for alpha, beta, gamma in zip(err_tr, err_det,Sum_Pij)]
        phi_opti = min(phi)
        indices = [i for i in range(len(phi)) if phi[i] == phi_opti]
        opti_epsi = [round(Epsi[i],3) for i in indices]

        #---------------------------------------------------------------------COMBINE PHI FUNCTION WITH ENTROPY FUNCTION--------------------------------------------------
        if len(opti_epsi)>1:
            count = 0
            Entropy = np.zeros(len(opti_epsi))
            for e in opti_epsi:
                R = np.array(D<e)
                R=R.astype(int)

                Serie = symbolic_series.symbolic_serie(R)

                p = np.array(np.unique(Serie).shape[0])
                H=0
                occurrences = np.bincount(Serie)
                for valeur, nb_occurrences in enumerate(occurrences):
                    if nb_occurrences > 0:
                        pi = nb_occurrences/Serie.shape[0]
                        H=H+pi*np.log2(pi)

                Hneg = -H
                Entropy[count]= Hneg
                count=count+1

            # Results epsilon
            Hmax = np.max(Entropy)
            IndxHmax = np.argmax(Entropy)
            EpsiOptiH = opti_epsi[IndxHmax]
        else:
            EpsiOptiH = opti_epsi[0]

        #--------------------------------------------------------------Complexity--------------------------------------------------------------------------------------------
        D = cdist(y, y, 'euclidean')
        R = np.array(D<EpsiOptiH)
        R=R.astype(int)

        serie = symbolic_series.symbolic_serie(R)
        C_alphabet_size,C_nbr_words,C_LZ = symbolic_series.complexity(serie)

        def loss_fct(alpha_des,word_des,Lz_des,C_alphabet_size,C_nbr_words,C_LZ):
            loss = abs(alpha_des-C_alphabet_size)+abs(word_des-C_nbr_words)+abs(Lz_des-C_LZ)
            return loss

        loss = loss_fct(alpha_des,word_des,Lz_des,C_alphabet_size,C_nbr_words,C_LZ)
        if loss < best_loss and C_LZ>=Lz_des_min and C_LZ<=Lz_des_max:
        #if loss < best_loss:
            w1_best = w1
            w2_best = w2
            lam_best = lam
            #C_alpha_best = C_alphabet_size
            #C_word_best = C_nbr_words
            #C_Lz_best = C_LZ
            best_loss = loss
        if loss < tol:
            break
    if w1_best == None:
        print("Lempel-Ziv complexity is not good. This data can't be used.")
    else:
      phi = [w1_best*alpha + w2_best*beta + lam_best*gamma for alpha, beta, gamma in zip(err_tr, err_det,Sum_Pij)]
      """
      print("")
      print("\n--------------------------------------------------Results-------------------------------------------------------")
      print('\nBest w1 = ',w1_best)
      print('Best w2 = ', w2_best)
      print('Best lambda = ',lam_best)
      """
      phi_opti = min(phi)
      indices = [i for i in range(len(phi)) if phi[i] == phi_opti]
      opti_epsi = [round(Epsi[i],3) for i in indices]
      #---------------------------------------------------------------------COMBINE PHI FUNCTION WITH ENTROPY FUNCTION--------------------------------------------------
      if len(opti_epsi)>1:
          count = 0
          Entropy = np.zeros(len(opti_epsi))
          for e in opti_epsi:
              R = np.array(D<e)
              R=R.astype(int)

              Serie = symbolic_series.symbolic_serie(R)

              p = np.array(np.unique(Serie).shape[0])
              H=0
              occurrences = np.bincount(Serie)
              for valeur, nb_occurrences in enumerate(occurrences):
                  if nb_occurrences > 0:
                      pi = nb_occurrences/Serie.shape[0]
                      H=H+pi*np.log2(pi)

              Hneg = -H
              Entropy[count]= Hneg
              count=count+1

          # Results epsilon
          Hmax = np.max(Entropy)
          IndxHmax = np.argmax(Entropy)
          EpsiOptiH = opti_epsi[IndxHmax]
      else:
          EpsiOptiH = opti_epsi[0]
      """"
      print('Optimal epsilon = ',EpsiOptiH)
      print("Loss = ",best_loss)
      print("\nTarget C_alphabet= ",alpha_des)    
      print('C_alphabet = ', C_alpha_best)
      print("\nTarget C_nbr_words = ",word_des)
      print('C_words = ', C_word_best)
      #print("\nTarget C_LZ : ",Lz_des_min," ; ",Lz_des_max)
      print("\nTarget C_LZ = ",Lz_des)
      print('C_LZ = ', C_Lz_best)
      """

      if visu is not None:
        print('\n-----------Optimal Epsilon with Phi function-----------')
        print('Optimal Epsilon = ',EpsiOptiH)
        while(True):
          rep = input("\nDo you want to save your result ? (Y/n): ")
          if rep.lower() == 'y':
            if back_file is not None:
              with open(back_file, 'a') as fichier:
                  fichier.write('\n\n-----------Optimal Epsilon with Phi function-----------' + '\n' + str(round(EpsiOptiH, 3)))
              print(f"Optimal Epsilon with Phi function has been successfully saved in '{back_file}'")
            else :
              while True:
                name_file = input("Please, give a name to your backup file: ")
                if not os.path.exists(f'{name_file}'):
                  with open(name_file, 'w') as fichier:
                    fichier.write('\n\n-----------Optimal Epsilon with Phi function-----------' + '\n' + str(round(EpsiOptiH, 3)))
                  print(f"Optimal Epsilon with Phi function has been successfully saved in '{name_file}'")
                  break
                else:
                    rep2 = input(f"The file '{name_file}' already exists. Do you want to replace it ? (Y/n): ")
                if rep2.lower() == 'y':
                  with open(name_file, 'w') as fichier:
                    fichier.write('\n\n-----------Optimal Epsilon with Phi function-----------' + '\n' + str(round(EpsiOptiH, 3)))
                  print(f"Optimal Epsilon with Phi function has been successfully saved in '{name_file}'")
                  break
                else:
                  rep3 = input(f"Do you want to add your serie in it ? (Y/n): ")
                if rep3.lower() == 'y':
                  with open(name_file, 'a') as fichier:
                    fichier.write('\n\n-----------Optimal Epsilon with Utility function-----------' + '\n' + str(round(EpsiOptiH, 3)))
                  print(f"Optimal Epsilon with Phi function has been successfully saved in '{name_file}'")
                  break
            break
          elif rep.lower() == 'n':
            break
          
      return EpsiOptiH
    
def find_CLZ(length):
    doc = np.array([[50, 5, 4],[100, 7, 5],[150, 9, 6],[200, 11, 7],[250, 12, 8]])
    test=float('inf')
    for i in range(len(doc[:,0])):
        dist = doc[i,0]-length
        if 0<dist and dist<test:
            div_max = doc[i,2]
            div_min = doc[i-1,1]
            test=doc[i,0]-length
        elif dist == 0:
            div_max = doc[i,2]
            div_min = doc[i,1]
            break
    tbl_lz =[]
    lim_min=round(length/div_min)
    lim_max=round(length/div_max)
    while(True):
        for i in range(10000):

            num_subseries_state1 = 20
            num_subseries_state2 = 20
            num_subseries_state0 = 20

            avg_length_state1 = 10
            avg_length_state2 = 10
            avg_length_state0 = 5

            std_dev_length_variation = 4

            subseries_state1 = []
            subseries_state2 = []
            subseries_state0 = []

            for _ in range(num_subseries_state1):
                subseries_length = max(1, int(np.random.normal(avg_length_state1, std_dev_length_variation)))
                subseries_state1.append(np.ones(subseries_length))

            for _ in range(num_subseries_state2):
                subseries_length = max(1, int(np.random.normal(avg_length_state2, std_dev_length_variation)))
                subseries_state2.append(2 * np.ones(subseries_length))

            for _ in range(num_subseries_state0):
                subseries_length = max(1, int(np.random.normal(avg_length_state0, std_dev_length_variation)))
                subseries_state0.append(np.zeros(subseries_length))

            series = []
            state_sequence = [1, 0, 2, 0]
            state_index = random.randint(0,2)

            while len(series) < length:
                current_state = state_sequence[state_index % len(state_sequence)]
                
                if current_state == 1:
                    subseries = subseries_state1[np.random.randint(len(subseries_state1))]
                elif current_state == 2:
                    subseries = subseries_state2[np.random.randint(len(subseries_state2))]
                else:
                    subseries = subseries_state0[np.random.randint(len(subseries_state0))]
                
                series.extend(subseries)
                
                state_index += 1
            series = np.array(series[:length])
            C_alpha,C_word,C_LZ=symbolic_series.complexity(series)
            tbl_lz.append(C_LZ)

        count_min=0
        count_max=0
        for nbr in tbl_lz:
            if nbr < lim_min:
                count_min = count_min+1
            if nbr > lim_max:
                count_max = count_max+1
        if count_min>0:
            lim_min=lim_min-1
        if count_max>0:
            lim_max=lim_max+1
        if count_min==0 and count_max==0:
            break

    return lim_min, lim_max
        
          
          